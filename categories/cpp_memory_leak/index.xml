<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp_memory_leak on gumeng's blog.</title><link>https://blog.guyuemeng.com/categories/cpp_memory_leak/</link><description>Recent content in cpp_memory_leak on gumeng's blog.</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 22 Feb 2021 22:15:22 +0800</lastBuildDate><atom:link href="https://blog.guyuemeng.com/categories/cpp_memory_leak/index.xml" rel="self" type="application/rss+xml"/><item><title>019 overloaded lambda</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/019_overloaded_lambda/</link><pubDate>Mon, 22 Feb 2021 22:15:22 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/019_overloaded_lambda/</guid><description>Overloaded lambda 一个有趣的话题：如何重载lambda。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &amp;lt;iomanip&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;type_traits&amp;gt;#include &amp;lt;variant&amp;gt;#include &amp;lt;vector&amp;gt; // the variant to visit using var_t = std::variant&amp;lt;int, long, double, std::string&amp;gt;; // helper type</description></item><item><title>018 default initialization</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/018_default_initialization/</link><pubDate>Wed, 11 Nov 2020 19:01:22 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/018_default_initialization/</guid><description>Default Initialization[1] 1 2 3 4 5 // Syntax T object; new T new T() // (until C++03) 默认初始化场景 具有automatic(栈上)、static、thread-local生命周期的对象未显示</description></item><item><title>015 17s structured binding declaration</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/015_17s_structured_binding_declaration/</link><pubDate>Sun, 17 May 2020 21:31:02 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/015_17s_structured_binding_declaration/</guid><description>Video Link: C++ Weekly - Ep 24 C++17&amp;rsquo;s Structured Bindings Verification Case 结构化绑定是一个比较有意思的功能，从某个角度来看，使用{}可以将数据打包成tuple/array/class等，结构</description></item><item><title>014 17s nested namespace</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/014_17s_nested_namespace/</link><pubDate>Sun, 17 May 2020 17:04:06 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/014_17s_nested_namespace/</guid><description>Video Link: C++ Weekly - Ep 22 C++17&amp;rsquo;s Nested Namespaces and std::clamp Verification Case 嵌套命名空间是一个非常小的写法改进，如： 1 2 3 4 // Style1 namespace A { namespace B { namespace C { }}} 或： 1 2 3 4 5 6 7 8 // Style2 namespace A { namespace B { namespace C</description></item><item><title>013 17s if with initializer</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/013_17s_if_with_initializer/</link><pubDate>Sat, 16 May 2020 23:23:28 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/013_17s_if_with_initializer/</guid><description>Video Link: C++ Weekly - Ep 21 C++17&amp;rsquo;s if and switch Init Statements 应用场景 首先看下其等效表达[1]： 1 2 3 4 5 6 7 { init_statement if constexpr(optional) ( condition ) statement-true else statement-false } 与普通的if几乎相同，唯一的区别是最外层的{</description></item><item><title>012 17s constexpr if</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/012_17s_constexpr_if/</link><pubDate>Mon, 11 May 2020 20:43:00 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/012_17s_constexpr_if/</guid><description>Video Link: C++ Weekly - Ep 18 C++17&amp;rsquo;s constexpr if Verification Case constexpr if用于在编译期进行分支选择，不满足条件的分支在编译期被丢弃。从某种程度上来说，constexpr if有着#if.</description></item><item><title>011 member function factory</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/011_member_function_factory/</link><pubDate>Mon, 27 Apr 2020 00:33:56 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/011_member_function_factory/</guid><description>010_17s_invoke提到的std::invoke提供了统一的非静态成员函数和普通函数的统一调用，但遗留个问题：使用场景。 回忆方舟编译</description></item><item><title>010 17s invoke</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/010_17s_invoke/</link><pubDate>Sat, 25 Apr 2020 19:43:08 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/010_17s_invoke/</guid><description>Video Link: C++ Weekly - Ep 17 C++17&amp;rsquo;s std::invoke Background 非静态成员函数与普通函数在使用函数指针进行调用的方式不同[1][2]。 普通函数指针： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int sum(int lhs,</description></item><item><title>009 lambda rather than bind</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/009_lambda_rather_than_bind/</link><pubDate>Sun, 19 Apr 2020 21:52:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/009_lambda_rather_than_bind/</guid><description>Video Link: C++ Weekly - Ep 15 Using std::bind, C++ Weekly - Ep 16 Avoiding std::bind Verification Case 示例如下，有add函数： 1 2 3 int add(int a, int b) { return a + b; } 现要通过其支持步进1(add(i, 1))，使用std</description></item><item><title>008 17s fold expression</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/008_17s_fold_expression/</link><pubDate>Wed, 15 Apr 2020 23:39:49 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/008_17s_fold_expression/</guid><description>本文用于初步探索C++17引入的fold expression特性来简化parameter pack的使用。 Verification Case 在&amp;quot;003_refac</description></item><item><title>007 14s exchange</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/007_14s_exchange/</link><pubDate>Mon, 13 Apr 2020 23:30:53 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/007_14s_exchange/</guid><description>Video Link: C++ Weekly - Ep 14 Standard Library Gems: next and exchange Optimization Case https://gitee.com/harmonyos/OpenArkCompiler/blob/master/src/maple_ir/src/mir_lower.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BlockNode *MIRLower::LowerBlock(BlockNode &amp;amp;block) { auto *newBlock = mirModule.CurFuncCodeMemPool()-&amp;gt;New&amp;lt;BlockNode&amp;gt;(); BlockNode *tmp = nullptr; if (block.GetFirst() == nullptr) { return newBlock; } StmtNode *nextStmt = block.GetFirst(); ASSERT(nextStmt != nullptr, &amp;#34;nullptr check&amp;#34;); do { StmtNode *stmt = nextStmt; nextStmt = stmt-&amp;gt;GetNext(); //</description></item><item><title>006 17s any</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/006_17s_any/</link><pubDate>Sun, 12 Apr 2020 17:28:08 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/006_17s_any/</guid><description>本文用于初步探索C++17引入的std::any的使用。 Verification Case 知识补充 c++是静态类型的语言，python是动态类型的语言。从个人经历而言，很</description></item><item><title>005 17s optional</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/005_17s_optional/</link><pubDate>Thu, 09 Apr 2020 23:55:36 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/005_17s_optional/</guid><description>本文用于初步探索C++17引入的std::optional的使用与性能。 Verification Case 知识补充 如下代码，或多或少还是会见到一些： 1 2 3 4 5 6 7 8 9 10 11</description></item><item><title>004 usage of static local</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/004_usage_of_static_local/</link><pubDate>Mon, 06 Apr 2020 22:24:12 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/004_usage_of_static_local/</guid><description>Video Link: C++ Weekly - Ep 2 Cost of Using Statics 此视频的目的是探索static局部变量的开销。 Verification Case 知识补充 c++ 11前单件的实现需要线程安全的双重校验，其实现可能如下： 1</description></item><item><title>003 refactor multi fill to single expression</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/003_refactor_multi_fill_to_single_expression/</link><pubDate>Sat, 04 Apr 2020 23:44:46 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/003_refactor_multi_fill_to_single_expression/</guid><description>基于002_refactor_char_operation_to_utility中的初始化，依然有两点对于应用不友好： 多次书写单个参数不同的</description></item><item><title>002 refactor char operation to utility</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/002_refactor_char_operation_to_utility/</link><pubDate>Sat, 04 Apr 2020 18:48:13 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/002_refactor_char_operation_to_utility/</guid><description>基于001_refactor_logic_to_static中的模块提供更为通用的抽象，凸显主题业务，并提高代码可复用性。 待优化的代码如下：</description></item><item><title>001 refactor logic to static</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/001_refactor_logic_to_static/</link><pubDate>Fri, 03 Apr 2020 18:25:34 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/001_refactor_logic_to_static/</guid><description>Video Link: C++ Weekly - Ep 1 ChaiScript_Parser Initialization Refactor 此视频的目标：将代码中具有初始化语义的代码进行重构，以此可以更多的利用编译器能力进行优化，从而获得更高的性能。 Optimization Case https://gitee.com/harmonyos/OpenArkCompiler/blob/master/src/maple_ir/src/lexer.cpp 1 2</description></item></channel></rss>