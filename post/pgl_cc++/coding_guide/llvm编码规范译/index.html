<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>LLVM编码规范(译) - Blog for gumeng.</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="孤梦"><meta name=description content="LLVM Coding Standards(LLVM编码规范) [TOC] Introduction(简介) This document attempts to describe a few coding standards that are being used in the LLVM source tree. Although no coding standards should be regarded as absolute requirements to be followed in"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.83.1 with theme even"><link rel=canonical href=http://localhost:1313/post/pgl_cc++/coding_guide/llvm%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E8%AF%91/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="LLVM编码规范(译)"><meta property="og:description" content="LLVM Coding Standards(LLVM编码规范) [TOC] Introduction(简介) This document attempts to describe a few coding standards that are being used in the LLVM source tree. Although no coding standards should be regarded as absolute requirements to be followed in"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/post/pgl_cc++/coding_guide/llvm%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E8%AF%91/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-07-15T23:39:17+08:00"><meta property="article:modified_time" content="2019-07-15T23:39:17+08:00"><meta itemprop=name content="LLVM编码规范(译)"><meta itemprop=description content="LLVM Coding Standards(LLVM编码规范) [TOC] Introduction(简介) This document attempts to describe a few coding standards that are being used in the LLVM source tree. Although no coding standards should be regarded as absolute requirements to be followed in"><meta itemprop=datePublished content="2019-07-15T23:39:17+08:00"><meta itemprop=dateModified content="2019-07-15T23:39:17+08:00"><meta itemprop=wordCount content="30214"><meta itemprop=keywords content="coding-guide,c/c++,llvm,"><meta name=twitter:card content="summary"><meta name=twitter:title content="LLVM编码规范(译)"><meta name=twitter:description content="LLVM Coding Standards(LLVM编码规范) [TOC] Introduction(简介) This document attempts to describe a few coding standards that are being used in the LLVM source tree. Although no coding standards should be regarded as absolute requirements to be followed in"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>孤梦</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>孤梦</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>LLVM编码规范(译)</h1><div class=post-meta><span class=post-time>2019-07-15</span><div class=post-category><a href=/categories/llvm/>llvm</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#llvm-coding-standardsllvm编码规范>LLVM Coding Standards(LLVM编码规范)</a><ul><li><a href=#introductionhttpllvmorgdocscodingstandardshtmlid1简介><a href=http://llvm.org/docs/CodingStandards.html#id1>Introduction</a>(简介)</a></li><li><a href=#languages-libraries-and-standardshttpllvmorgdocscodingstandardshtmlid2语言库和标准><a href=http://llvm.org/docs/CodingStandards.html#id2>Languages, Libraries, and Standards</a>(语言、库和标准)</a><ul><li><a href=#c-standard-versionshttpllvmorgdocscodingstandardshtmlid3c标准版本><a href=http://llvm.org/docs/CodingStandards.html#id3>C++ Standard Versions</a>(C++标准版本)</a></li><li><a href=#c-standard-libraryhttpllvmorgdocscodingstandardshtmlid4c标准库><a href=http://llvm.org/docs/CodingStandards.html#id4>C++ Standard Library</a>(C++标准库)</a></li><li><a href=#supported-c11-language-and-library-featureshttpllvmorgdocscodingstandardshtmlid5支持的c11语言与库特性><a href=http://llvm.org/docs/CodingStandards.html#id5>Supported C++11 Language and Library Features</a>(支持的C++11语言与库特性)</a></li><li><a href=#other-languageshttpllvmorgdocscodingstandardshtmlid6其他语言><a href=http://llvm.org/docs/CodingStandards.html#id6>Other Languages</a>(其他语言)</a></li></ul></li><li><a href=#mechanical-source-issueshttpllvmorgdocscodingstandardshtmlid7><a href=http://llvm.org/docs/CodingStandards.html#id7>Mechanical Source Issues</a></a><ul><li><a href=#source-code-formattinghttpllvmorgdocscodingstandardshtmlid8源码格式><a href=http://llvm.org/docs/CodingStandards.html#id8>Source Code Formatting</a>(源码格式)</a></li><li><a href=#language-and-compiler-issueshttpllvmorgdocscodingstandardshtmlid21语言和编译器><a href=http://llvm.org/docs/CodingStandards.html#id21>Language and Compiler Issues</a>(语言和编译器)</a></li></ul></li><li><a href=#style-issueshttpllvmorgdocscodingstandardshtmlid32格式><a href=http://llvm.org/docs/CodingStandards.html#id32>Style Issues</a>(格式)</a><ul><li><a href=#the-high-level-issueshttpllvmorgdocscodingstandardshtmlid33高级主题><a href=http://llvm.org/docs/CodingStandards.html#id33>The High-Level Issues</a>(高级主题)</a></li><li><a href=#the-low-level-issueshttpllvmorgdocscodingstandardshtmlid41初级主题><a href=http://llvm.org/docs/CodingStandards.html#id41>The Low-Level Issues</a>(初级主题)</a></li><li><a href=#microscopic-detailshttpllvmorgdocscodingstandardshtmlid53小细节><a href=http://llvm.org/docs/CodingStandards.html#id53>Microscopic Details</a>(小细节)</a></li></ul></li><li><a href=#see-alsohttpllvmorgdocscodingstandardshtmlid58><a href=http://llvm.org/docs/CodingStandards.html#id58>See Also</a></a></li></ul></li><li><a href=#译注>译注</a></li></ul></nav></div></div><div class=post-content><h1 id=llvm-coding-standardsllvm编码规范>LLVM Coding Standards(LLVM编码规范)</h1><p>[TOC]</p><h2 id=introductionhttpllvmorgdocscodingstandardshtmlid1简介><a href=http://llvm.org/docs/CodingStandards.html#id1>Introduction</a>(简介)</h2><p>This document attempts to describe a few coding standards that are being used in the LLVM source tree. Although no coding standards should be regarded as absolute requirements to be followed in all instances, coding standards are particularly important for large-scale code bases that follow a library-based design (like LLVM).</p><p>【译】本文描述了一些LLVM源码库中正在使用的编码规范。虽说并不存在可以完美适用于所有场景的编码规范，但编码规范对大规模代码工程还是比较重要的，尤其是做类库设计（如LLVM）。</p><p>While this document may provide guidance for some mechanical formatting issues, whitespace, or other “microscopic details”, these are not fixed standards. Always follow the golden rule:</p><blockquote><p><strong>If you are extending, enhancing, or bug fixing already implemented code, use the style that is already being used so that the source is uniform and easy to follow.</strong></p></blockquote><p>【译】虽然本文对一些纯格式问题（如空格等小细节）提供了指导，但这并不是一成不变的标准。往往遵循以下黄金准则：</p><blockquote><p>如果在存量代码中进行扩展、增强或问题修复，遵循存量代码的编码风格。这样保证了源码风格统一，大家更容易去遵循。</p></blockquote><p>Note that some code bases (e.g. <code>libc++</code>) have really good reasons to deviate from the coding standards. In the case of <code>libc++</code>, this is because the naming and other conventions are dictated by the C++ standard. If you think there is a specific good reason to deviate from the standards here, please bring it up on the LLVM-dev mailing list.</p><p>【译】请注意，有一些代码库有比较好的理由不遵从该编码规范，如<code>libc++</code>，其命名以及其他约定由C++标准所制定。如果你有一个明确的好理由需要违反该编码规范，请在LLVM-dev邮件列表中提出。</p><p>There are some conventions that are not uniformly followed in the code base (e.g. the naming convention). This is because they are relatively new, and a lot of code was written before they were put in place. Our long term goal is for the entire codebase to follow the convention, but we explicitly <em>do not</em> want patches that do large-scale reformatting of existing code. On the other hand, it is reasonable to rename the methods of a class if you’re about to change it in some other way. Just do the reformatting as a separate commit from the functionality change.</p><p>【译】代码库中，有一些约定（如命名规则）并没有统一遵守，这是因为在它们之前就已经编写了大量代码，它们的添加相对较新。我们的长期目标肯定是使整个代码库都遵循该规范，但我们也不希望在补丁包中做大量的基础代码重构。另一方面，如果你想以其他方式重命名类成员函数，这是合理的，但需要将重构代码单独提交，请勿和功能代码混在一起。</p><p>The ultimate goal of these guidelines is to increase the readability and maintainability of our common source base. If you have suggestions for topics to be included, please mail them to <a href=mailto:sabre%40nondot.org>Chris</a>.</p><p>【译】这些指导的最终目标是提升我们公共代码库的可读性和可维护性。如果你有些新增项的建议，请给Chris邮件。</p><p><em>【注】编码规范大致可以分为格式规范与安全规范两类，而安全规范又可以分为功能性规范与攻击防护型规范。格式规范往往遵从工作模块的整体风格，其注重团队成员编码和阅读无障碍，并不是所有规范都有完善的理由，更倾向于公约；功能性规范关注在编程语言使用上的陷阱，由于编程语言设计的通用性、应用场景的扩张、软硬件的革新等等原因，一些写法或组合更容易导致功能性问题，或在可扩展性可阅读性等方面有更好的设计，这类规范的理由比较充分；攻击防护型规范指的是编程语言设计的缺陷，或应用场景的限制，如脚本注入、不安全随机数等。</em></p><h2 id=languages-libraries-and-standardshttpllvmorgdocscodingstandardshtmlid2语言库和标准><a href=http://llvm.org/docs/CodingStandards.html#id2>Languages, Libraries, and Standards</a>(语言、库和标准)</h2><p>Most source code in LLVM and other LLVM projects using these coding standards is C++ code. There are some places where C code is used either due to environment restrictions, historical restrictions, or due to third-party source code imported into the tree. Generally, our preference is for standards conforming, modern, and portable C++ code as the implementation language of choice.</p><p>【译】LLVM以及使用该编码规范的其他LLVM工程，其大部分源码均是用C++编写，但由于环境限制、历史原因或第三方源码库的导入，目前仍存在一些C代码。通常来说，我们更倾向于把符合规范的、可移植的C++代码作为实现语言的首选。</p><h3 id=c-standard-versionshttpllvmorgdocscodingstandardshtmlid3c标准版本><a href=http://llvm.org/docs/CodingStandards.html#id3>C++ Standard Versions</a>(C++标准版本)</h3><p>LLVM, Clang, and LLD are currently written using C++11 conforming code, although we restrict ourselves to features which are available in the major toolchains supported as host compilers. The LLDB project is even more aggressive in the set of host compilers supported and thus uses still more features. Regardless of the supported features, code is expected to (when reasonable) be standard, portable, and modern C++11 code. We avoid unnecessary vendor-specific extensions, etc.</p><p>【译】虽然我们仅限于使用主流编译器支持的核心工具链所使用的C++特性，但当前LLVM、Clang和LLD均使用C++实现。LLDB工程在使用各主流编译器支持的特性上，显得更为激进，它使用了更多的C++特性。除了已支持的特性，在合理的情况下，代码都应该由标准的、可移植的C++11编写。我们不会接纳非必要的、小众特化的扩展。</p><h3 id=c-standard-libraryhttpllvmorgdocscodingstandardshtmlid4c标准库><a href=http://llvm.org/docs/CodingStandards.html#id4>C++ Standard Library</a>(C++标准库)</h3><p>Use the C++ standard library facilities whenever they are available for a particular task. LLVM and related projects emphasize and rely on the standard library facilities for as much as possible. Common support libraries providing functionality missing from the standard library for which there are standard interfaces or active work on adding standard interfaces will often be implemented in the LLVM namespace following the expected standard interface.</p><p>【译】只要对特定任务可用，请使用C++标准库。LLVM以及相关项目都尽可能的依赖于标准库。对于公共库中缺失的功能，如果有标准接口或待添加标准接口，那么通常会在LLVM命名空间下，按照期望的标准接口实现。</p><p>There are some exceptions such as the standard I/O streams library which are avoided. Also, there is much more detailed information on these subjects in the <a href=http://llvm.org/docs/ProgrammersManual.html>LLVM Programmer’s Manual</a>.</p><p>【译】也有一些例外，如标准库中的I/O流操作是被禁用的。另外，对于这块更多的详情可参考《LLVM Programmer’s Manual》。</p><h3 id=supported-c11-language-and-library-featureshttpllvmorgdocscodingstandardshtmlid5支持的c11语言与库特性><a href=http://llvm.org/docs/CodingStandards.html#id5>Supported C++11 Language and Library Features</a>(支持的C++11语言与库特性)</h3><p>While LLVM, Clang, and LLD use C++11, not all features are available in all of the toolchains which we support. The set of features supported for use in LLVM is the intersection of those supported in the minimum requirements described in the <a href=http://llvm.org/docs/GettingStarted.html>Getting Started with the LLVM System</a> page, section <em>Software</em>. The ultimate definition of this set is what build bots with those respective toolchains accept. Don’t argue with the build bots. However, we have some guidance below to help you know what to expect.</p><p>【译】虽然LLVM、Clang和LLD均使用C++11，但并不是所有C++11特性都可用于我们支持的全部工具链。LLVM可用的C++11特性集是《Getting Started with the LLVM System》中Software章节所描述的最小需求的交集。这个特性集的最终确立来源于各工具链所接纳特性集的自动构建。一切以自动构建为准。同时，我们下面有一些指导来帮助了解哪些特性是可用的。</p><p>Each toolchain provides a good reference for what it accepts:</p><p>【译】每个工具链均对其接纳的特性提供了很好地参考：</p><ul><li>Clang: <a href=https://clang.llvm.org/cxx_status.html>https://clang.llvm.org/cxx_status.html</a></li><li>GCC: <a href=https://gcc.gnu.org/projects/cxx-status.html#cxx11>https://gcc.gnu.org/projects/cxx-status.html#cxx11</a></li><li>MSVC: <a href=https://msdn.microsoft.com/en-us/library/hh567368.aspx>https://msdn.microsoft.com/en-us/library/hh567368.aspx</a></li></ul><p>In most cases, the MSVC list will be the dominating factor. Here is a summary of the features that are expected to work. Features not on this list are unlikely to be supported by our host compilers.</p><p>【译】大多数情况下，MSVC列表将是主导因素。以下是可用特性的概要信息，除此之外的特性并不太可能被我们主流编译器所支持。</p><ul><li><p>Rvalue references: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html>N2118</a></p><ul><li>But <em>not</em> Rvalue references for <code>*this</code> or member qualifiers (<a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm>N2439</a>)</li></ul></li></ul><p>【注】右值引用：除<code>*this</code>和成员修饰符(<em>ref-qualifiers</em>)的右值引用</p><ul><li>Static assert: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html>N1720</a></li></ul><p>【注】静态断言：static_assert，对常量表达式和模板参数在编译期进行检查</p><ul><li><code>auto</code> type deduction: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf>N1984</a>, <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1737.pdf>N1737</a></li></ul><p>【注】自动类型推导：auto关键字</p><ul><li>Trailing return types: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm>N2541</a></li></ul><p>【注】尾置返回类型：lambda返回值类型表示，以及解决通过decltype推导依赖输入的返回值类型时，编译器尚未捕获输入类型的缺陷。</p><blockquote><p>Trailing return type, useful if the return type depends on argument names, such as</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=k>class</span> <span class=nc>U</span><span class=o>&gt;</span>
<span class=k>auto</span> <span class=n>add</span><span class=p>(</span><span class=n>T</span> <span class=n>t</span><span class=p>,</span> <span class=n>U</span> <span class=n>u</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=n>t</span> <span class=o>+</span> <span class=n>u</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>or is complicated, such as in</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>auto</span> <span class=n>fpif</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=o>-&gt;</span><span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></blockquote><ul><li><p>Lambdas: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf>N2927</a></p><ul><li>But <em>not</em> lambdas with default arguments.</li></ul></li></ul><p>【注】lambda表达式：除默认参数上的lambda表达式***（存疑）***</p><blockquote><p>A <em>lambda-expression</em> appearing in a default argument shall not implicitly or explicitly capture any entity. [ <em>Example:</em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>f2</span><span class=p>()</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
  <span class=kt>void</span> <span class=n>g1</span><span class=p>(</span><span class=kt>int</span> <span class=o>=</span> <span class=p>([</span><span class=n>i</span><span class=p>]{</span> <span class=k>return</span> <span class=n>i</span><span class=p>;</span> <span class=p>})());</span>			<span class=c1>// ill-formed
</span><span class=c1></span>  <span class=kt>void</span> <span class=n>g2</span><span class=p>(</span><span class=kt>int</span> <span class=o>=</span> <span class=p>([</span><span class=n>i</span><span class=p>]{</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=p>})());</span>			<span class=c1>// ill-formed
</span><span class=c1></span>  <span class=kt>void</span> <span class=n>g3</span><span class=p>(</span><span class=kt>int</span> <span class=o>=</span> <span class=p>([</span><span class=o>=</span><span class=p>]{</span> <span class=k>return</span> <span class=n>i</span><span class=p>;</span> <span class=p>})());</span>			<span class=c1>// ill-formed
</span><span class=c1></span>  <span class=kt>void</span> <span class=n>g4</span><span class=p>(</span><span class=kt>int</span> <span class=o>=</span> <span class=p>([</span><span class=o>=</span><span class=p>]{</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=p>})());</span>			<span class=c1>// OK
</span><span class=c1></span>  <span class=kt>void</span> <span class=n>g5</span><span class=p>(</span><span class=kt>int</span> <span class=o>=</span> <span class=p>([]{</span> <span class=k>return</span> <span class=k>sizeof</span> <span class=n>i</span><span class=p>;</span> <span class=p>})());</span>	<span class=c1>// OK
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p><em>—end example</em> ]</p></blockquote><ul><li><code>decltype</code>: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf>N2343</a></li><li>Nested closing right angle brackets: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html>N1757</a></li></ul><p>【注】模板右尖括号嵌套：c98版本模板中<code>>></code>会被解析为右移，需要添加空格隔开<code>> ></code>，C++11开始支持叠用</p><ul><li>Extern templates: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1987.htm>N1987</a></li></ul><p>【注】外部模板：非模板函数的extern声明关键字，扩展到模板函数</p><ul><li><code>nullptr</code>: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf>N2431</a></li></ul><p>【注】模板特化场景下，<code>0</code>或<code>NULL</code>作为空指针时，推导类型为<code>int</code>而非<code>*</code>，导致匹配错误。</p><ul><li>Strongly-typed and forward declarable enums: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf>N2347</a>, <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf>N2764</a></li></ul><p>【注】强类型枚举：<code>enum class</code>代替<code>enum</code>可解决同命名空间下不同枚举类型拥有相同枚举成员名会报错的问题；C++03版本枚举类型视为整数，可与整数、其他枚举类型比较和互转，强枚举类型限制了这种不安全的隐式转换。</p><ul><li>Local and unnamed types as template arguments: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm>N2657</a></li></ul><p>【译】局部类型和匿名类型作为模板实参</p><ul><li><p>Range-based for-loop: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html>N2930</a></p><ul><li>But <code>{}</code> are required around inner <code>do {} while()</code> loops. As a result, <code>{}</code> are required around function-like macros inside range-based for loops.</li></ul></li></ul><p>【注】基于范围的for循环：内部使用<code>do {} while()</code>时，需要添加<code>{}</code>。同样，基于范围的for循环内部的函数式宏也需要<code>{}</code>包围。</p><ul><li><code>override</code> and <code>final</code>: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2928.htm>N2928</a>, <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm>N3206</a>, <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm>N3272</a></li></ul><p>【注】<code>override</code>通过编译检查，确保子类虚函数重写基类虚函数，若子类与基类虚函数不一致，则编译报错；<code>final</code>标记在类上时，该类无法被继承，<code>final</code>标记在虚函数上，虚函数无法被子类重写，否则编译报错。</p><ul><li>Atomic operations and the C++11 memory model: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2429.htm>N2429</a></li></ul><p>【注】原子操作与C++11内存模型：并发与线程安全</p><ul><li>Variadic templates: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf>N2242</a></li></ul><p>【译】变参模板</p><ul><li>Explicit conversion operators: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf>N2437</a></li></ul><p>【注】显示类型转换运算符：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>B</span> <span class=p>{</span>
    <span class=k>explicit</span> <span class=nf>B</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
    <span class=k>explicit</span> <span class=nf>B</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
    <span class=k>explicit</span> <span class=k>operator</span> <span class=nf>bool</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>}</span>
<span class=p>};</span>
<span class=n>B</span> <span class=n>b1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>      <span class=c1>// 错误：复制初始化不考虑 B::B(int)
</span><span class=c1></span><span class=n>B</span> <span class=nf>b2</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>       <span class=c1>// OK：直接初始化选择 B::B(int)
</span><span class=c1></span><span class=n>B</span> <span class=n>b3</span> <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>   <span class=c1>// OK：直接列表初始化选择 B::B(int, int)
</span><span class=c1></span><span class=n>B</span> <span class=n>b4</span> <span class=o>=</span> <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span> <span class=c1>// 错误：复制列表初始化不考虑 B::B(int,int)
</span><span class=c1></span><span class=n>B</span> <span class=n>b5</span> <span class=o>=</span> <span class=p>(</span><span class=n>B</span><span class=p>)</span><span class=mi>1</span><span class=p>;</span>   <span class=c1>// OK：显式转型进行 static_cast
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>b2</span><span class=p>);</span>       <span class=c1>// OK：B::operator bool()
</span><span class=c1></span><span class=kt>bool</span> <span class=n>nb1</span> <span class=o>=</span> <span class=n>b2</span><span class=p>;</span> <span class=c1>// 错误：复制初始化不考虑 B::operator bool()
</span><span class=c1></span><span class=kt>bool</span> <span class=n>nb2</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=p>(</span><span class=n>b2</span><span class=p>);</span> <span class=c1>// OK：static_cast 进行直接初始化
</span></code></pre></td></tr></table></div></div><ul><li>Defaulted and deleted functions: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm>N2346</a></li></ul><p>【注】默认函数：default关键字；删除函数：delete关键字</p><ul><li>Initializer lists: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm>N2627</a></li></ul><p>【译】初始化列表</p><ul><li>Delegating constructors: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf>N1986</a></li></ul><p>【注】委托构造函数：一个类的构造函数可以通过调用它的其他构造进行初始化，但其自身不能再初始化成员变量。</p><ul><li><p>Default member initializers (non-static data member initializers): <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2756.htm>N2756</a></p><ul><li>Feel free to use these wherever they make sense and where the = syntax is allowed. Don’t use braced initialization syntax.</li></ul></li></ul><p>【注】默认成员初始化（非静态成员初始化）：成员初始化列表优先级高于默认成员初始化。此场景下，请勿使用大括号初始化语法<code>C c4 = C{};</code></p><p>The supported features in the C++11 standard libraries are less well tracked, but also much greater. Most of the standard libraries implement most of C++11’s library. The most likely lowest common denominator is Linux support. For libc++, the support is just poorly tested and undocumented but expected to be largely complete. YMMV. For libstdc++, the support is documented in detail in <a href=https://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/manual/manual/status.html#status.iso.2011>the libstdc++ manual</a>. There are some very minor missing facilities that are unlikely to be common problems, and there are a few larger gaps that are worth being aware of:</p><p>【译】C++11标准库中支持的特性跟踪的不太好，而且这个量还比较大。大多数标准库实现了大部分C++11库中的特性。目测Linux支持的特性可能是最少的。对于libc++，支持的特性也缺少测试和文档，但预计大部分会完善。对于libstdc++，其中手册中详细记录支持的特性。有一些非常小的缺失特性，这不太可能是普遍的问题，倒是有一些大的缺口需要特别注意：</p><ul><li>Not all of the type traits are implemented</li></ul><p>【译】不是所有类型萃取都已实现</p><ul><li>No regular expression library.</li></ul><p>【译】无正则表达式库</p><ul><li>While most of the atomics library is well implemented, the fences are missing. Fortunately, they are rarely needed.</li></ul><p>【译】大多数原子库都实现的很好，但栅栏（约束内存乱序）相关内容缺失了。幸运的是，他们极少被用到。</p><ul><li>The locale support is incomplete.</li></ul><p>【译】系统区域设置（国家或地区设置）的支持不完善。</p><p>Other than these areas you should assume the standard library is available and working as expected until some build bot tells you otherwise. If you’re in an uncertain area of one of the above points, but you cannot test on a Linux system, your best approach is to minimize your use of these features, and watch the Linux build bots to find out if your usage triggered a bug. For example, if you hit a type trait which doesn’t work we can then add support to LLVM’s traits header to emulate it.</p><p>【译】除了这些点，你应该认为标准库是可用的，而且会按照预期工作，直到某些构建工具提示错误。如果你对上述某个点不确认，而且无法在Linux系统上进行测试，那最好少用这些特性，以及通过Linux构建工具来找出你的使用是否触发了缺陷。</p><h3 id=other-languageshttpllvmorgdocscodingstandardshtmlid6其他语言><a href=http://llvm.org/docs/CodingStandards.html#id6>Other Languages</a>(其他语言)</h3><p>Any code written in the Go programming language is not subject to the formatting rules below. Instead, we adopt the formatting rules enforced by the <a href=https://golang.org/cmd/gofmt/>gofmt</a> tool.</p><p>【译】Go语言编写的代码不受以下格式限制。作为替代，我们选用<code>gofmt</code>工具强制执行格式规范。</p><p>Go code should strive to be idiomatic. Two good sets of guidelines for what this means are <a href=https://golang.org/doc/effective_go.html>Effective Go</a> and <a href=https://github.com/golang/go/wiki/CodeReviewComments>Go Code Review Comments</a>.</p><p>【译】Go代码应该尽量符合其语言习惯。《Effective Go》和《Go Code Review Comments》对Go语言都是很好的指导 。</p><h2 id=mechanical-source-issueshttpllvmorgdocscodingstandardshtmlid7><a href=http://llvm.org/docs/CodingStandards.html#id7>Mechanical Source Issues</a></h2><h3 id=source-code-formattinghttpllvmorgdocscodingstandardshtmlid8源码格式><a href=http://llvm.org/docs/CodingStandards.html#id8>Source Code Formatting</a>(源码格式)</h3><h4 id=commentinghttpllvmorgdocscodingstandardshtmlid9注释><a href=http://llvm.org/docs/CodingStandards.html#id9>Commenting</a>(注释)</h4><p>Comments are one critical part of readability and maintainability. Everyone knows they should comment their code, and so should you. When writing comments, write them as English prose, which means they should use proper capitalization, punctuation, etc. Aim to describe what the code is trying to do and why, not <em>how</em> it does it at a micro level. Here are a few critical things to document:</p><p>【译】注释是可读性和可维护性的关键组成部分。每个人都知道他们应该给代码添加注释，你也是。像写英语散文一样去写注释，这也意味着注释应该使用适当的大写、标点等。**着重描述代码在做什么、为什么这么做，而不是微观层面的代码是怎么实现的。**以下是一些比较重要的内容，需要添加注释：</p><h5 id=file-headershttpllvmorgdocscodingstandardshtmlid10文件头><a href=http://llvm.org/docs/CodingStandards.html#id10>File Headers</a>(文件头)</h5><p>Every source file should have a header on it that describes the basic purpose of the file. If a file does not have a header, it should not be checked into the tree. The standard header looks like this:</p><p>每个源文件都应该有一个描述其基础用途的文件头注释。如果没有文件头注释，那么该文件不应该添加进代码分支中。标准文件头注释格式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>//===-- llvm/Instruction.h - Instruction class definition -------*- C++ -*-===//
</span><span class=c1>//
</span><span class=c1>// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
</span><span class=c1>// See https://llvm.org/LICENSE.txt for license information.
</span><span class=c1>// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
</span><span class=c1>//
</span><span class=c1>//===----------------------------------------------------------------------===//
</span><span class=c1>///
</span><span class=c1>/// \file
</span><span class=c1>/// This file contains the declaration of the Instruction class, which is the
</span><span class=c1>/// base class for all of the VM instructions.
</span><span class=c1>///
</span><span class=c1>//===----------------------------------------------------------------------===//
</span></code></pre></td></tr></table></div></div><p>A few things to note about this particular format: The “<code>-*- C++ -*-</code>” string on the first line is there to tell Emacs that the source file is a C++ file, not a C file (Emacs assumes <code>.h</code> files are C files by default).</p><p>【译】关于这种特殊格式需要注意：第一行的“<code>-*- C++ -*-</code>”用于告知Emacs这是个C++文件，而非C文件（Emacs默认<code>.h</code>为C文件）。</p><blockquote><p>Note(注意)</p><p>This tag is not necessary in <code>.cpp</code> files. The name of the file is also on the first line, along with a very short description of the purpose of the file. This is important when printing out code and flipping though lots of pages.</p><p>【译】<code>.cpp</code>文件中无需这个标记。文件名以及很短的文件用途描述也写在第一行，这在打印代码并且要翻阅很多页面时非常重要。</p></blockquote><p>The next section in the file is a concise note that defines the license that the file is released under. This makes it perfectly clear what terms the source code can be distributed under and should not be modified in any way.</p><p>【译】文件的下一段是对文件发布许可的简明注释。这清楚的表明了，在什么条件下源码可以传播，以及不应以任何方式进行修改。</p><p>The main body is a <code>doxygen</code> comment (identified by the <code>///</code> comment marker instead of the usual <code>//</code>) describing the purpose of the file. The first sentence (or a passage beginning with <code>\brief</code>) is used as an abstract. Any additional information should be separated by a blank line. If an algorithm is being implemented or something tricky is going on, a reference to the paper where it is published should be included, as well as any notes or <em>gotchas</em> in the code to watch out for.</p><p>【译】主体部分以<code>doxygen</code>注释格式（用<code>///</code>注释标记而非<code>//</code>）描述了该文件的目的。第一句（以<code>\brief</code>开头的段落）作为摘要，任何其他信息应以空行分隔。如果有正在实现的算法或正在处理的棘手问题，则需要包含相关论文的引用，以及代码注意项或陷阱。</p><h5 id=class-overviewshttpllvmorgdocscodingstandardshtmlid11类的概述><a href=http://llvm.org/docs/CodingStandards.html#id11>Class overviews</a>(类的概述)</h5><p>Classes are one fundamental part of a good object oriented design. As such, a class definition should have a comment block that explains what the class is used for and how it works. Every non-trivial class is expected to have a<code>doxygen</code> comment block.</p><p>【译】类是一个良好面向对象设计的基础部分。因此，类定义需要包含一个注释块，用于解释类的用途以及工作原理。每个重要类都需要有<code>doxygen</code>注释块。</p><h5 id=method-informationhttpllvmorgdocscodingstandardshtmlid12方法说明><a href=http://llvm.org/docs/CodingStandards.html#id12>Method information</a>(方法说明)</h5><p>Methods defined in a class (as well as any global functions) should also be documented properly. A quick note about what it does and a description of the borderline behaviour is all that is necessary here (unless something particularly tricky or insidious is going on). The hope is that people can figure out how to use your interfaces without reading the code itself.</p><p>【译】类成员方法（以及任何全局函数）也应该被恰当的注释。此处仅需要一个阐述其作用的简要注释以及对其边界行为的描述（除非发生一些特别困难的或有风险的事情）。期望达到这样的效果：使用者在不阅读代码实现细节的情况下就能弄清楚如何使用你的接口。</p><p>Good things to talk about here are what happens when something unexpected happens: does the method return null? Abort? Format your hard disk?</p><p>【译】这里最好讨论一些异常行为的反馈：方法是否返回空值？是否会导致程序退出？是否会格式化硬盘？</p><h4 id=comment-formattinghttpllvmorgdocscodingstandardshtmlid13注释的格式><a href=http://llvm.org/docs/CodingStandards.html#id13>Comment Formatting</a>(注释的格式)</h4><p>In general, prefer C++ style comments (<code>//</code> for normal comments, <code>///</code> for <code>doxygen</code> documentation comments). They take less space, require less typing, don’t have nesting problems, etc. There are a few cases when it is useful to use C style (<code>/* */</code>) comments however:</p><p>【译】通常，我们倾向于C++风格的注释（<code>//</code>用于普通注释，<code>///</code>用于<code>doxygen</code>文档注释）。这种注释风格占用比较少的空间、不需要打太多的字，也没有嵌套问题等等。但也有些情况C风格的注释（<code>/* */</code>）是比较有用的：</p><ol><li>When writing C code: Obviously if you are writing C code, use C style comments.</li></ol><p>【译】写C代码时：这个很好理解，写C代码时用C风格的注释。</p><ol start=2><li>When writing a header file that may be <code>#include</code>d by a C source file.</li></ol><p>【译】头文件：可能被C源文件包含时。</p><ol start=3><li>When writing a source file that is used by a tool that only accepts C style comments.</li></ol><p>【译】源文件：被一个仅支持C风格注释的工具所使用时。</p><ol start=4><li>When documenting the significance of constants used as actual parameters in a call. This is most helpful for <code>bool</code> parameters, or passing <code>0</code> or <code>nullptr</code>. Typically you add the formal parameter name, which ought to be meaningful. For example, it’s not clear what the parameter means in this call:</li></ol><p>【译】在函数调用中，描述常量实参的重要性时。这对<code>bool</code>参数，或者传0以及传<code>nullptr</code>的场景最有用。通常添加形参名字的注释应该就很有意义了。例如，在下面这个调用中，参数的含义并不清晰：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Object</span><span class=p>.</span><span class=n>emitName</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>An in-line C-style comment makes the intent obvious:</p><p>【译】内嵌的C风格注释让这个意图变得很明晰。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Object</span><span class=p>.</span><span class=n>emitName</span><span class=p>(</span><span class=cm>/*Prefix=*/</span><span class=k>nullptr</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>【注】通常会使用有意义的常量名、更有意义的函数名、或重构成员函数的设计等方式来让意图变得明晰。这类注释往往是不得已而为之，大部分场景下，恰恰证明此函数设计的缺陷，当重构之，而非注释之。</p><p>Commenting out large blocks of code is discouraged, but if you really have to do this (for documentation purposes or as a suggestion for debug printing), use <code>#if 0</code> and <code>#endif</code>. These nest properly and are better behaved in general than C style comments.</p><p>【译】不鼓励注释掉大块代码，但如果真的必须得这样做（出于文档的目的或者作为调试打印的建议），使用 <code>#if 0</code> 和 <code>#endif</code>。这些可以保证嵌套的正确性，而且通常比C风格的注释表现更好。</p><h4 id=doxygen-use-in-documentation-commentshttpllvmorgdocscodingstandardshtmlid14文档注释中doxygen的应用><a href=http://llvm.org/docs/CodingStandards.html#id14>Doxygen Use in Documentation Comments</a>(文档注释中Doxygen的应用)</h4><p>Use the <code>\file</code> command to turn the standard file header into a file-level comment.</p><p>【译】使用<code>\file</code>命令将标准文件头注释转换为文件级注释。</p><p>Include descriptive paragraphs for all public interfaces (public classes, member and non-member functions). Don’t just restate the information that can be inferred from the API name. The first sentence (or a paragraph beginning with <code>\brief</code>) is used as an abstract. Try to use a single sentence as the <code>\brief</code> adds visual clutter. Put detailed discussion into separate paragraphs.</p><p>【译】所有公共接口（公共类、成员与非成员函数）都需要包含一个描述性段落，不要只赘述那些可从API名称推断出来的信息。第一句（以<code>\brief</code>开头的段落）作为摘要，若<code>\brief</code>会产生混淆，试着使用单句。细节描述放到其他段落。</p><p>To refer to parameter names inside a paragraph, use the <code>\p name</code> command. Don’t use the <code>\arg name</code> command since it starts a new paragraph that contains documentation for the parameter.</p><p>【译】若要引用段落中的参数名称，使用<code>\p name</code>命令。不要使用<code>\arg name</code>命令，因为它会开始一个包含参数注释的新段。</p><p>Wrap non-inline code examples in <code>\code ... \endcode</code>.</p><p>【译】把非内联代码示例放在<code>\code ... \endcode</code>中。</p><p>To document a function parameter, start a new paragraph with the <code>\param name</code> command. If the parameter is used as an out or an in/out parameter, use the <code>\param [out] name</code> or <code>\param [in,out] name</code> command, respectively.</p><p>【译】若要注释函数参数，使用<code>\param name</code>新起一段。如果是一个输出或输入/输出参数，分别使用<code>\param [out] name</code>、<code>\param [in,out] name</code>命令。</p><p>To describe function return value, start a new paragraph with the <code>\returns</code> command.</p><p>【译】若要注释函数返回值，使用<code>\returns</code>新起一段。</p><p>A minimal documentation comment:</p><p>【译】一个极简的注释示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Sets the xyzzy property to \p Baz.
</span><span class=c1></span><span class=kt>void</span> <span class=nf>setXyzzy</span><span class=p>(</span><span class=kt>bool</span> <span class=n>Baz</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>A documentation comment that uses all Doxygen features in a preferred way:</p><p>【译】一个较好的使用了所有Doxygen特性的注释示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Does foo and bar.
</span><span class=c1>///
</span><span class=c1>/// Does not do foo the usual way if \p Baz is true.
</span><span class=c1>///
</span><span class=c1>/// Typical usage:
</span><span class=c1>/// \code
</span><span class=c1>///   fooBar(false, &#34;quux&#34;, Res);
</span><span class=c1>/// \endcode
</span><span class=c1>///
</span><span class=c1>/// \param Quux kind of foo to do.
</span><span class=c1>/// \param [out] Result filled with bar sequence on foo success.
</span><span class=c1>///
</span><span class=c1>/// \returns true on success.
</span><span class=c1></span><span class=kt>bool</span> <span class=nf>fooBar</span><span class=p>(</span><span class=kt>bool</span> <span class=n>Baz</span><span class=p>,</span> <span class=n>StringRef</span> <span class=n>Quux</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>Result</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>Don’t duplicate the documentation comment in the header file and in the implementation file. Put the documentation comments for public APIs into the header file. Documentation comments for private APIs can go to the implementation file. In any case, implementation files can include additional comments (not necessarily in Doxygen markup) to explain implementation details as needed.</p><p>【译】不要在头文件和实现文件中重复注释，将公共API的注释放在头文件中，将私有API的注释放在实现文件中。任何时候，实现文件都可以包含其他注释（不一定在Doxygen标记中），以便按需解释实现细节。</p><p>Don’t duplicate function or class name at the beginning of the comment. For humans it is obvious which function or class is being documented; automatic documentation processing tools are smart enough to bind the comment to the correct declaration.</p><p>【译】不要在注释的开头重复函数名或类名。因为哪个函数或类被注释是显而易见的，而且自动注释处理工具可以很智能的将注释关联到正确的声明上。</p><p>Wrong:</p><p>【译】错误示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// In Something.h:
</span><span class=c1></span>
<span class=c1>/// Something - An abstraction for some complicated thing.
</span><span class=c1></span><span class=k>class</span> <span class=nc>Something</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// fooBar - Does foo and bar.
</span><span class=c1></span>  <span class=kt>void</span> <span class=n>fooBar</span><span class=p>();</span>
<span class=p>};</span>

<span class=c1>// In Something.cpp:
</span><span class=c1></span>
<span class=c1>/// fooBar - Does foo and bar.
</span><span class=c1></span><span class=kt>void</span> <span class=n>Something</span><span class=o>::</span><span class=n>fooBar</span><span class=p>()</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Correct:</p><p>【译】正确做法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// In Something.h:
</span><span class=c1></span>
<span class=c1>/// An abstraction for some complicated thing.
</span><span class=c1></span><span class=k>class</span> <span class=nc>Something</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// Does foo and bar.
</span><span class=c1></span>  <span class=kt>void</span> <span class=n>fooBar</span><span class=p>();</span>
<span class=p>};</span>

<span class=c1>// In Something.cpp:
</span><span class=c1></span>
<span class=c1>// Builds a B-tree in order to do foo.  See paper by...
</span><span class=c1></span><span class=kt>void</span> <span class=n>Something</span><span class=o>::</span><span class=n>fooBar</span><span class=p>()</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><p>It is not required to use additional Doxygen features, but sometimes it might be a good idea to do so.</p><p>【译】一般来说，我们不需要再使用其他Doxygen特性，但有些情况下，使用其他特性会比较好。</p><p>Consider:</p><p>【译】思考下：</p><ul><li>adding comments to any narrow namespace containing a collection of related functions or types;</li></ul><p>【译】给用于包含关联函数或类型集的狭义命名空间添加注释；</p><ul><li>using top-level groups to organize a collection of related functions at namespace scope where the grouping is smaller than the namespace;</li></ul><p>【译】使用顶层分组在命名空间范围内组织关联函数集，其中分组范围小于命名空间；</p><ul><li>using member groups and additional comments attached to member groups to organize within a class.</li></ul><p>【译】使用成员分组，并附加额外的注释来管理类内的成员分组。</p><p>For example:</p><p>【译】例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>Something</span> <span class=p>{</span>
  <span class=c1>/// \name Functions that do Foo.
</span><span class=c1></span>  <span class=c1>/// @{
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>fooBar</span><span class=p>();</span>
  <span class=kt>void</span> <span class=nf>fooBaz</span><span class=p>();</span>
  <span class=c1>/// @}
</span><span class=c1></span>  <span class=p>...</span>
<span class=p>};</span>
</code></pre></td></tr></table></div></div><h4 id=include-stylehttpllvmorgdocscodingstandardshtmlid15include风格><a href=http://llvm.org/docs/CodingStandards.html#id15><code>#include</code> Style</a>(<code>#include</code>风格)</h4><p>Immediately after the <a href=http://llvm.org/docs/CodingStandards.html#header-file-comment>header file comment</a> (and include guards if working on a header file), the <a href=http://llvm.org/docs/CodingStandards.html#minimal-list-of-includes>minimal list of #includes</a> required by the file should be listed. We prefer these <code>#include</code>s to be listed in this order:</p><p>【译】在文件头注释之后（如果是头文件，在头文件保护符范围内），列出#include的最小集。我们希望按以下的顺序列出<code>#include</code>。</p><p>【注】<em>"#include的最小集"</em>，存在一定的歧义：不要引入多余的头文件，且头文件隐式包含的其他头文件不用再引入；不要引入多余的头文件，头文件隐式包含的其他头文件若因其他用途被需要，则仍需显示引入，避免隐式依赖。个人更倾向于后者。</p><ol><li>Main Module Header【译】主模块头文件</li><li>Local/Private Headers【译】临近/私有的头文件</li><li>LLVM project/subproject headers (<code>clang/...</code>, <code>lldb/...</code>, <code>llvm/...</code>, etc)【译】LLVM项目/子项目的头文件</li><li>System <code>#include</code>s【译】系统<code>#include</code></li></ol><p>and each category should be sorted lexicographically by the full path.</p><p>【译】并且每个分类需要按照全路径的的字典顺序进行排序。</p><p>【注】主模块头文件排第一，主要为保证头文件自包含。之后的文件分类排序在不同的公司标准中，大概可以分为这两类：由远及近、由通用到特殊、影响域逐渐缩小；由近及远、由特殊到通用、影响域逐渐增大。LLVM编码规范采用第二种。</p><p>The <a href=http://llvm.org/docs/CodingStandards.html#main-module-header>Main Module Header</a> file applies to <code>.cpp</code> files which implement an interface defined by a <code>.h</code> file. This <code>#include</code>should always be included <strong>first</strong> regardless of where it lives on the file system. By including a header file first in the <code>.cpp</code> files that implement the interfaces, we ensure that the header does not have any hidden dependencies which are not explicitly <code>#include</code>d in the header, but should be. It is also a form of documentation in the <code>.cpp</code> file to indicate where the interfaces it implements are defined.</p><p>【译】若<code>.cpp</code>文件实现了某<code>.h</code>文件定义的接口，此<code>.h</code>文件为该<code>.cpp</code>文件的主模块头文件。无论该文件位于何处，它都始终应该被第一个<code>#include</code>，这样就能确保头没有没有任何隐式依赖。同时，这也是一种文档形式，用于表明该<code>.cpp</code>文件实现的接口定义在哪里。</p><p>LLVM project and subproject headers should be grouped from most specific to least specific, for the same reasons described above. For example, LLDB depends on both clang and LLVM, and clang depends on LLVM. So an LLDB source file should include <code>lldb</code> headers first, followed by <code>clang</code> headers, followed by <code>llvm</code> headers, to reduce the possibility (for example) of an LLDB header accidentally picking up a missing include due to the previous inclusion of that header in the main source file or some earlier header file. clang should similarly include its own headers before including llvm headers. This rule applies to all LLVM subprojects.</p><p>【译】出于和上述相同的原因，LLVM项目和子项目的头文件也应该按照从特殊到通用的原则分组。举例来说，LLDB依赖clang和LLVM，同时clang也依赖于LLVM。那么，一个LLDB源文件应先包含<code>lldb</code>头文件，其次是<code>clang</code>头文件，接着是<code>llvm</code>头文件。这样可降低因在此之前主源文件或头文件引入了头文件，导致LLDB头文件缺少包含的可能性。同理，clang应该先包含自己的头文件，然后才是llvm头文件。此规则适用于所有LLVM子项目。</p><h4 id=source-code-widthhttpllvmorgdocscodingstandardshtmlid16源码行宽><a href=http://llvm.org/docs/CodingStandards.html#id16>Source Code Width</a>(源码行宽)</h4><p>Write your code to fit within 80 columns of text. This helps those of us who like to print out code and look at your code in an <code>xterm</code> without resizing it.</p><p>【译】代码行宽不超过80个字符，这有助于喜欢打印代码或在<code>xterm</code>上阅读代码的人无需重新调整行宽大小。</p><p>The longer answer is that there must be some limit to the width of the code in order to reasonably allow developers to have multiple files side-by-side in windows on a modest display. If you are going to pick a width limit, it is somewhat arbitrary but you might as well pick something standard. Going with 90 columns (for example) instead of 80 columns wouldn’t add any significant value and would be detrimental to printing out code. Also many other projects have standardized on 80 columns, so some people have already configured their editors for it (vs something else, like 90 columns).</p><p>【译】更长远的解释，为适度的允许开发者在适中的显示器窗口上将多个文件并排放置，代码行宽必须要进行一些限制。如果你准备选择一个行宽限制，这某种程度上有些随意，但我们还是有些标准可供选择的。例如使用90列而非80列，这并不会添加什么重要信息，反而不利于打印代码。此外，许多其他项目已经使用80列作为标准，有些人已经为此配置好了编辑器（和其他列宽如90列相比）</p><p>This is one of many contentious issues in coding standards, but it is not up for debate.</p><p>【译】这是编码规范中有争议的问题之一，但还没上升到需要辩论的地步。</p><h4 id=whitespacehttpllvmorgdocscodingstandardshtmlid17空格><a href=http://llvm.org/docs/CodingStandards.html#id17>Whitespace</a>(空格)</h4><p>In all cases, prefer spaces to tabs in source files. People have different preferred indentation levels, and different styles of indentation that they like; this is fine. What isn’t fine is that different editors/viewers expand tabs out to different tab stops. This can cause your code to look completely unreadable, and it is not worth dealing with.</p><p>【译】在任何时候，优先使用空格而不是tab。不同的人倾向不同的缩进级别和缩进风格，这是合理的。但不同的编辑器或阅读器将tab展开为不同的宽度展示，这会导致你的代码看起来完全不可读，且没有继续理解的必要。</p><p>As always, follow the <a href=http://llvm.org/docs/CodingStandards.html#golden-rule>Golden Rule</a> above: follow the style of existing code if you are modifying and extending it. If you like four spaces of indentation, <strong>DO NOT</strong> do that in the middle of a chunk of code with two spaces of indentation. Also, do not reindent a whole source file: it makes for incredible diffs that are absolutely worthless.</p><p>【译】如上文所说，遵循以下黄金法则：如果修改或扩展存量代码，遵循现有代码风格。无论你多么喜欢4空格缩进，请勿在两空格缩进的代码块中使用。此外，不要调整整个源文件的缩进风格：这会产生毫无意义但令人费解的差异。</p><p>Do not commit changes that include trailing whitespace. If you find trailing whitespace in a file, do not remove it unless you’re otherwise changing that line of code. Some common editors will automatically remove trailing whitespace when saving a file which causes unrelated changes to appear in diffs and commits.</p><p>【译】请勿提交行尾带有空格的变更。如果文件中有行尾带空格的代码，除非正在修改那行，否则不要修改（如上文所述：格式化、重构和功能开发应以不同的patch提交）。一些常见的编辑器会在保存文件时自动删除行尾的空格，这会导致无关的变更出现在差异和提交（git commit的变更比较）中。</p><h4 id=indent-code-consistentlyhttpllvmorgdocscodingstandardshtmlid18代码缩进一致><a href=http://llvm.org/docs/CodingStandards.html#id18>Indent Code Consistently</a>（代码缩进一致）</h4><p>Okay, in your first year of programming you were told that indentation is important. If you didn’t believe and internalize this then, now is the time. Just do it. With the introduction of C++11, there are some new formatting challenges that merit some suggestions to help have consistent, maintainable, and tool-friendly formatting and indentation.</p><p>【译】在你接触程序开发的第一年，会被告知缩进很重要。如果你不信也不想接受这点，现在是时候了，做吧。随着C++11的推出，一些新的格式挑战，需要一些建议来帮助实现一致的、可维护的、工具有好的格式和缩进。</p><h5 id=format-lambdas-like-blocks-of-codehttpllvmorgdocscodingstandardshtmlid19像代码块一样格式化lambda表达式><a href=http://llvm.org/docs/CodingStandards.html#id19>Format Lambdas Like Blocks Of Code</a>(像代码块一样格式化lambda表达式)</h5><p>When formatting a multi-line lambda, format it like a block of code, that’s what it is. If there is only one multi-line lambda in a statement, and there are no expressions lexically after it in the statement, drop the indent to the standard two space indent for a block of code, as if it were an if-block opened by the preceding part of the statement:</p><p>【译】使用代码块的风格来格式化多行lambda表达式。如果一条语句中仅包含一个多行lambda，且之后没有词法表达式，则使用标准的两空格缩进，就像展开的if块。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>foo</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>foo</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=n>Foo</span> <span class=n>a</span><span class=p>,</span> <span class=n>Foo</span> <span class=n>b</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>bool</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>blah</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>blah</span><span class=p>)</span>
    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>baz</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>baz</span><span class=p>)</span>
    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
  <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>bam</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>bam</span><span class=p>;</span>
<span class=p>});</span>
</code></pre></td></tr></table></div></div><p>To take best advantage of this formatting, if you are designing an API which accepts a continuation or single callable argument (be it a functor, or a <code>std::function</code>), it should be the last argument if at all possible.</p><p>【译】如果你正在设计一个接受连续或单个可调用的参数（仿函数或<code>std::function</code>），为了充分利用这种格式的优势，尽可能把它作为最后一个参数。</p><p>If there are multiple multi-line lambdas in a statement, or there is anything interesting after the lambda in the statement, indent the block two spaces from the indent of the <code>[]</code>:</p><p>【译】如果一条语句中包含多个多行lambda，或lambda后还有其他内容，相对<code>[]</code>的缩进，lambda块内容再缩进两个空格。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>dyn_switch</span><span class=p>(</span><span class=n>V</span><span class=o>-&gt;</span><span class=n>stripPointerCasts</span><span class=p>(),</span>
           <span class=p>[]</span> <span class=p>(</span><span class=n>PHINode</span> <span class=o>*</span><span class=n>PN</span><span class=p>)</span> <span class=p>{</span>
             <span class=c1>// process phis...
</span><span class=c1></span>           <span class=p>},</span>
           <span class=p>[]</span> <span class=p>(</span><span class=n>SelectInst</span> <span class=o>*</span><span class=n>SI</span><span class=p>)</span> <span class=p>{</span>
             <span class=c1>// process selects...
</span><span class=c1></span>           <span class=p>},</span>
           <span class=p>[]</span> <span class=p>(</span><span class=n>LoadInst</span> <span class=o>*</span><span class=n>LI</span><span class=p>)</span> <span class=p>{</span>
             <span class=c1>// process loads...
</span><span class=c1></span>           <span class=p>},</span>
           <span class=p>[]</span> <span class=p>(</span><span class=n>AllocaInst</span> <span class=o>*</span><span class=n>AI</span><span class=p>)</span> <span class=p>{</span>
             <span class=c1>// process allocas...
</span><span class=c1></span>           <span class=p>});</span>
</code></pre></td></tr></table></div></div><h5 id=braced-initializer-listshttpllvmorgdocscodingstandardshtmlid20大括号初始化列表><a href=http://llvm.org/docs/CodingStandards.html#id20>Braced Initializer Lists</a>(大括号初始化列表)</h5><p>With C++11, there are significantly more uses of braced lists to perform initialization. These allow you to easily construct aggregate temporaries in expressions among other niceness. They now have a natural way of ending up nested within each other and within function calls in order to build up aggregates (such as option structs) from local variables. To make matters worse, we also have many more uses of braces in an expression context that are <em>not</em> performing initialization.</p><p>【译】在C++11中，使用大括号进行列表初始化的情况多了很多。它使你很容易在表达式中结构化组合临时值，当然还有其他好处。它们现在可以很自然的在函数调用中相互嵌套，以此通过局部变量构建组合结构（如选项结构）。嵌套过多并不好，而更糟糕的是，一个表达式的上下文中同样会有更多执行初始化的大括号。</p><p>The historically common formatting of braced initialization of aggregate variables does not mix cleanly with deep nesting, general expression contexts, function arguments, and lambdas. We suggest new code use a simple rule for formatting braced initialization lists: act as-if the braces were parentheses in a function call. The formatting rules exactly match those already well understood for formatting nested function calls.</p><p>【译】基于历史经验，聚合变量的大括号初始化通常不会与深层嵌套、一般的表达式、函数参数以及lambda混在一起。建议新代码使用简单的规则来格式化大括号初始化列表：就像函数调用中大括号的行为。其格式化规范和嵌套函数调用的格式化规范完全一致。</p><p>Examples:</p><p>【译】示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>foo</span><span class=p>({</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>},</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>});</span>

<span class=n>llvm</span><span class=o>::</span><span class=n>Constant</span> <span class=o>*</span><span class=n>Mask</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
    <span class=n>llvm</span><span class=o>::</span><span class=n>ConstantInt</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>Type</span><span class=o>::</span><span class=n>getInt32Ty</span><span class=p>(</span><span class=n>getLLVMContext</span><span class=p>()),</span> <span class=mi>0</span><span class=p>),</span>
    <span class=n>llvm</span><span class=o>::</span><span class=n>ConstantInt</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>Type</span><span class=o>::</span><span class=n>getInt32Ty</span><span class=p>(</span><span class=n>getLLVMContext</span><span class=p>()),</span> <span class=mi>1</span><span class=p>),</span>
    <span class=n>llvm</span><span class=o>::</span><span class=n>ConstantInt</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>Type</span><span class=o>::</span><span class=n>getInt32Ty</span><span class=p>(</span><span class=n>getLLVMContext</span><span class=p>()),</span> <span class=mi>2</span><span class=p>)};</span>
</code></pre></td></tr></table></div></div><p>This formatting scheme also makes it particularly easy to get predictable, consistent, and automatic formatting with tools like <a href=https://clang.llvm.org/docs/ClangFormat.html>Clang Format</a>.</p><p>【译】这样的格式化方案，可以很方便的利用自动格式化工具(如Clang Format)得到可以预计的、稳定的格式。</p><h3 id=language-and-compiler-issueshttpllvmorgdocscodingstandardshtmlid21语言和编译器><a href=http://llvm.org/docs/CodingStandards.html#id21>Language and Compiler Issues</a>(语言和编译器)</h3><h4 id=treat-compiler-warnings-like-errorshttpllvmorgdocscodingstandardshtmlid22将编译器告警视为错误><a href=http://llvm.org/docs/CodingStandards.html#id22>Treat Compiler Warnings Like Errors</a>(将编译器告警视为错误)</h4><p>If your code has compiler warnings in it, something is wrong — you aren’t casting values correctly, you have “questionable” constructs in your code, or you are doing something legitimately wrong. Compiler warnings can cover up legitimate errors in output and make dealing with a translation unit difficult.</p><p>【译】如果代码存在编译告警，说明有问题——没有正确的类型转换，有可疑的构造，或者正在做错误的操作。编译告警会掩盖输出中的错误，并让编译器翻译单元处理起来更困难。</p><p>It is not possible to prevent all warnings from all compilers, nor is it desirable. Instead, pick a standard compiler (like <code>gcc</code>) that provides a good thorough set of warnings, and stick to it. At least in the case of <code>gcc</code>, it is possible to work around any spurious errors by changing the syntax of the code slightly. For example, a warning that annoys me occurs when I write code like this:</p><p>【译】处理所有编译器的所有告警是不太现实的，也不可取。相反，挑一个有一套标准优质告警的编译器（如gcc）作为标准，并坚持下去。至少像gcc这样的编译器，可以通过稍微修改代码语法来解决任何误报。例如，下面这种写法会报出一个恼人的告警：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>V</span> <span class=o>=</span> <span class=n>getValue</span><span class=p>())</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p><code>gcc</code> will warn me that I probably want to use the <code>==</code> operator, and that I probably mistyped it. In most cases, I haven’t, and I really don’t want the spurious errors. To fix this particular problem, I rewrite the code like this:</p><p>【译】<code>gcc</code>将提醒这里可能期望使用<code>==</code>，但手误写成了<code>=</code>。大多数情况下，我并没有写错，我不需要这种误报。为了修复这个特殊问题，重构代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>((</span><span class=n>V</span> <span class=o>=</span> <span class=n>getValue</span><span class=p>()))</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>which shuts <code>gcc</code> up. Any <code>gcc</code> warning that annoys you can be fixed by massaging the code appropriately.</p><p>【译】这规避了告警，任何<code>gcc</code>告警都可以通过适当改变代码来修复。</p><p>【注】warning中确实存在一些有争议的项，通常编译器有关闭某类告警的开关。但此处举例不恰当，最大的问题在<code>if ((V = getValue()))</code>中，<code>V = getValue()</code>先执行赋值动作，然后<code>V</code>做布尔类型转换，前者破坏条件表达式中判断表达式只做判断的单一职责，后者采用默认转换语义不清。此写法不值得推荐，如果想限制<code>V</code>的作用域，请抽函数或使用<code>{}</code>控制，推荐写法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>auto</span> <span class=n>V</span> <span class=o>=</span> <span class=n>getValue</span><span class=p>();</span>
<span class=k>if</span> <span class=p>(</span><span class=n>V</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=write-portable-codehttpllvmorgdocscodingstandardshtmlid23写可移植的代码><a href=http://llvm.org/docs/CodingStandards.html#id23>Write Portable Code</a>(写可移植的代码)</h4><p>In almost all cases, it is possible and within reason to write completely portable code. If there are cases where it isn’t possible to write portable code, isolate it behind a well defined (and well documented) interface.</p><p>【译】几乎在所有情况下，写完全可移植的代码是可行的，而且是合理的。如果某些场景不太可能写出可移植的代码，将其隔离在一个定义完善的(注释完善)接口内。</p><p>【注】使用接口隔离是开发过程常见的手段，在一个紧迫交付的需求或知识不足以写出一定水准的代码时，往往会将这段设计粗糙、修改频繁或理解不足的代码剥离出来实现，这样可以在后续继续演进、以及当编码水平达到一定程度后重构。设计规则：可以容忍脏乱差的代码存在一定时间，但不能污染已有代码，或影响后续调用者。</p><p>In practice, this means that you shouldn’t assume much about the host compiler (and Visual Studio tends to be the lowest common denominator). If advanced features are used, they should only be an implementation detail of a library which has a simple exposed API, and preferably be buried in <code>libSystem</code>.</p><p>【译】这意味着在写代码的时候，不应该对主流编译器做过多假设（Visual Studio做的最差）。如果使用了高级功能，那他们的实现细节应该隐藏在库中，并只暴露简单的接口。</p><p>【注】接口与实现分离，接口抽象往往具有完整局部业务结构，并不是任意函数的堆砌，这是常犯的问题。接口中暴露必要的信息，而不是越多越好，尽量避免二次接口依赖，衡量标准：在头文件自包含的情况下，引用非公共的头文件应该合理的尽量少。</p><h4 id=do-not-use-rtti-or-exceptionshttpllvmorgdocscodingstandardshtmlid24禁用运行时类型识别和异常><a href=http://llvm.org/docs/CodingStandards.html#id24>Do not use RTTI or Exceptions</a>(禁用运行时类型识别和异常)</h4><p>In an effort to reduce code and executable size, LLVM does not use RTTI (e.g. <code>dynamic_cast&lt;>;</code>) or exceptions. These two language features violate the general C++ principle of <em>“you only pay for what you use”</em>, causing executable bloat even if exceptions are never used in the code base, or if RTTI is never used for a class. Because of this, we turn them off globally in the code.</p><p>【译】为了代码和可执行文件大小，LLVM不使用RTTI（如<code>dynamic_cast&lt;>;</code>）和异常。这两种语言特性违反了“你只用为你所用付出代价”的通用C++原则，它们会导致代码膨胀，而且即使异常未被使用，或者RTTI未用于某个类。因此，我们在全局代码中禁用了它们。</p><p>That said, LLVM does make extensive use of a hand-rolled form of RTTI that use templates like <a href=http://llvm.org/docs/ProgrammersManual.html#isa>isa&lt;>, cast&lt;>, and dyn_cast&lt;></a>. This form of RTTI is opt-in and can be <a href=http://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html>added to any class</a>. It is also substantially more efficient than <code>dynamic_cast&lt;></code>.</p><p>【译】也就是说，LLVM广泛使用了手动形式的RTTI，如 <code>isa&lt;></code>, <code>cast&lt;></code>, and <code>dyn_cast&lt;></code>等模板。这类形式的RTTI是可用的，并可添加到任何类中。而且它也比<code>dynamic_cast&lt;></code>更高效。</p><h4 id=do-not-use-static-constructorshttpllvmorgdocscodingstandardshtmlid25禁用静态构造><a href=http://llvm.org/docs/CodingStandards.html#id25>Do not use Static Constructors</a>(禁用静态构造)</h4><p>Static constructors and destructors (e.g. global variables whose types have a constructor or destructor) should not be added to the code base, and should be removed wherever possible. Besides <a href=https://yosefk.com/c++fqa/ctors.html#fqa-10.12>well known problems</a> where the order of initialization is undefined between globals in different source files, the entire concept of static constructors is at odds with the common use case of LLVM as a library linked into a larger application.</p><p>【译】静态构造和析构（如，类型中包含构造函数和析构函数的全局变量）不应添加到代码库中，并应尽可能删除。除了在不同源文件中全局变量之间的初始化顺序不确定这个众所周知的问题外，静态构造的整个概念都和LLVM作为库链接到大型软件这样的常见场景相悖。</p><p>【注】这里Static Constructor推断应理解为静态构造，构建并初始化全局对象或类内的静态对象等，而非静态构造函数的含义。</p><p>Consider the use of LLVM as a JIT linked into another application (perhaps for <a href=https://llvm.org/Users.html>OpenGL, custom languages</a>, <a href=https://llvm.org/devmtg/2010-11/Gritz-OpenShadingLang.pdf>shaders in movies</a>, etc). Due to the design of static constructors, they must be executed at startup time of the entire application, regardless of whether or how LLVM is used in that larger application. There are two problems with this:</p><p>【译】考虑LLVM作为JIT链接到另外一个软件的情况（可能用于OpenGL、定制语言、OpenShadingLanguage等）。由于设计了静态构造，无论LLVM在大型应用中是否被用到，它们必须在整个应用程序启动时执行。这就存在两个问题：</p><ul><li>The time to run the static constructors impacts startup time of applications — a critical time for GUI apps, among others.</li></ul><p>【译】运行静态构造影响应用的启动时间——这是GUI应用的主要时间，等等。</p><ul><li>The static constructors cause the app to pull many extra pages of memory off the disk: both the code for the constructor in each <code>.o</code> file and the small amount of data that gets touched. In addition, touched/dirty pages put more pressure on the VM system on low-memory machines.</li></ul><p>【译】静态构造让应用从磁盘中提取许多额外的内存页：包括每个<code>.o</code>文件中的构造代码，以及少量相关数据。另外，在内存紧缺的机器上，涉及的额外内存页给VM系统增加了更多的压力。</p><p>We would really like for there to be zero cost for linking in an additional LLVM target or other library into an application, but static constructors violate this goal.</p><p>【译】我们希望应用程序链接一个LLVM项目或其他库时零消耗，但静态构造违背了这个目标。</p><p>That said, LLVM unfortunately does contain static constructors. It would be a <a href=https://llvm.org/PR11944>great project</a> for someone to purge all static constructors from LLVM, and then enable the <code>-Wglobal-constructors</code> warning flag (when building with Clang) to ensure we do not regress in the future.</p><p>【译】但不幸的是，LLVM着实包含了静态构造。如果有人可以清除LLVM中所有的静态构造，并启用<code>-Wglobal-constructors</code>告警选项（当用Clang编译时）来保证这个特性不会退化，那将是个伟大的工程。</p><h4 id=use-of-class-and-struct-keywordshttpllvmorgdocscodingstandardshtmlid26class和struct关键字的使用><a href=http://llvm.org/docs/CodingStandards.html#id26>Use of <code>class</code> and <code>struct</code> Keywords</a>(<code>class</code>和<code>struct</code>关键字的使用)</h4><p>In C++, the <code>class</code> and <code>struct</code> keywords can be used almost interchangeably. The only difference is when they are used to declare a class: <code>class</code> makes all members private by default while <code>struct</code> makes all members public by default.</p><p>【译】在C++中，<code>class</code>和<code>struct</code>关键字几乎可以互换。唯一的区别是当他们用于声明类时：<code>class</code>默认所有成员私有，而<code>struct</code>默认所有成员公有。</p><p>Unfortunately, not all compilers follow the rules and some will generate different symbols based on whether <code>class</code> or <code>struct</code> was used to declare the symbol (e.g., MSVC). This can lead to problems at link time.</p><p>【译】然而不幸的是，并不是所有编译器都遵循这个规则，有些编译器（如MSVC）会将<code>class</code>和<code>struct</code>关键字声明的符号生成为不同的符号。这可能会导致链接时问题。</p><ul><li>All declarations and definitions of a given <code>class</code> or <code>struct</code> must use the same keyword. For example:</li></ul><p>【译】给定<code>class</code>或<code>struct</code>的所有声明和定义必须使用相同的关键字，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>Foo</span><span class=p>;</span>

<span class=c1>// Breaks mangling in MSVC.
</span><span class=c1></span><span class=k>struct</span> <span class=nc>Foo</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>Data</span><span class=p>;</span> <span class=p>};</span>
</code></pre></td></tr></table></div></div><ul><li>As a rule of thumb, <code>struct</code> should be kept to structures where <em>all</em> members are declared public.</li></ul><p>【译】根据经验，<code>struct</code>关键字仅限于使用在所有成员都声明为公有的情况下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Foo feels like a class... this is strange.
</span><span class=c1></span><span class=k>struct</span> <span class=nc>Foo</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
  <span class=kt>int</span> <span class=n>Data</span><span class=p>;</span>
<span class=k>public</span><span class=o>:</span>
  <span class=n>Foo</span><span class=p>()</span> <span class=o>:</span> <span class=n>Data</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
  <span class=kt>int</span> <span class=nf>getData</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Data</span><span class=p>;</span> <span class=p>}</span>
  <span class=kt>void</span> <span class=nf>setData</span><span class=p>(</span><span class=kt>int</span> <span class=n>D</span><span class=p>)</span> <span class=p>{</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>D</span><span class=p>;</span> <span class=p>}</span>
<span class=p>};</span>

<span class=c1>// Bar isn&#39;t POD, but it does look like a struct.
</span><span class=c1></span><span class=k>struct</span> <span class=nc>Bar</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>Data</span><span class=p>;</span>
  <span class=n>Bar</span><span class=p>()</span> <span class=o>:</span> <span class=n>Data</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
<span class=p>};</span>
</code></pre></td></tr></table></div></div><h4 id=do-not-use-braced-initializer-lists-to-call-a-constructorhttpllvmorgdocscodingstandardshtmlid27禁用大括号初始化列表来调用构造函数><a href=http://llvm.org/docs/CodingStandards.html#id27>Do not use Braced Initializer Lists to Call a Constructor</a>(禁用大括号初始化列表来调用构造函数)</h4><p>In C++11 there is a “generalized initialization syntax” which allows calling constructors using braced initializer lists. Do not use these to call constructors with any interesting logic or if you care that you’re calling some <em>particular</em> constructor. Those should look like function calls using parentheses rather than like aggregate initialization. Similarly, if you need to explicitly name the type and call its constructor to create a temporary, don’t use a braced initializer list. Instead, use a braced initializer list (without any type for temporaries) when doing aggregate initialization or something notionally equivalent. Examples:</p><p>【译】在C++11中，有个"通用初始化语法"：使用大括号初始化列表调用构造函数。不要使用这来调用具有任何特殊逻辑的构造函数，以及某个特定的构造函数。这看起来更像使用括号的函数而不是聚合初始化。同样的，如果需要显示指定类型，并使用其构造函数来创建一个临时变量，不要使用大括号初始化列表。相反，不显示指定类型时，在聚合初始化或类似的情况下，使用大括号初始化列表（无任何类型的临时变量）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>// Construct a Foo by reading data from the disk in the whizbang format, ...
</span><span class=c1></span>  <span class=n>Foo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>filename</span><span class=p>);</span>

  <span class=c1>// Construct a Foo by looking up the Nth element of some global data ...
</span><span class=c1></span>  <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>N</span><span class=p>);</span>

  <span class=c1>// ...
</span><span class=c1></span><span class=p>};</span>

<span class=c1>// The Foo constructor call is very deliberate, no braces.
</span><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>fill</span><span class=p>(</span><span class=n>foo</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>foo</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>Foo</span><span class=p>(</span><span class=s>&#34;name&#34;</span><span class=p>));</span>

<span class=c1>// The pair is just being constructed like an aggregate, use braces.
</span><span class=c1></span><span class=n>bar_map</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=n>my_key</span><span class=p>,</span> <span class=n>my_value</span><span class=p>});</span>
</code></pre></td></tr></table></div></div><p>If you use a braced initializer list when initializing a variable, use an equals before the open curly brace:</p><p>【译】当使用大括号初始化列表初始化变量时，在大括号前使用等号。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>int</span> <span class=n>data</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</code></pre></td></tr></table></div></div><h4 id=use-auto-type-deduction-to-make-code-more-readablehttpllvmorgdocscodingstandardshtmlid28使用auto自动类型推导提升代码可读性><a href=http://llvm.org/docs/CodingStandards.html#id28>Use <code>auto</code> Type Deduction to Make Code More Readable</a>(使用<code>auto</code>自动类型推导提升代码可读性)</h4><p>Some are advocating a policy of “almost always <code>auto</code>” in C++11, however LLVM uses a more moderate stance. Use <code>auto</code> if and only if it makes the code more readable or easier to maintain. Don’t “almost always” use <code>auto</code>, but do use<code>auto</code> with initializers like <code>cast&lt;Foo>(...)</code> or other places where the type is already obvious from the context. Another time when <code>auto</code> works well for these purposes is when the type would have been abstracted away anyways, often behind a container’s typedef such as <code>std::vector&lt;T>::iterator</code>.</p><p>【译】有些人在C++11中提倡"全部总是<code>auto</code>"，但llvm采取更加适度的态度。当且仅当<code>auto</code>能使代码可读性更强、可维护性更好时才使用它。不要"全部总是"使用<code>auto</code>，但像在<code>cast&lt;Foo>(…)</code>这样的初始化或类型在上下文显而易见的场景下，确实应该使用<code>auto</code>。另外，在类型反正会被抽象化的情况下，通常是某个容器内的<code>typedef</code>如<code>std::vector&lt;T>::iterator</code>，<code>auto</code>的效果也很好。</p><p>【注】<code>auto</code>是一种类似于强类型语言python变量定义的语义，形式上又如弱类型语言javascript中的<code>var</code>。这种方式的体验感很是酸爽，一方面代码表现的很简洁，不啰嗦；另外一方面，即使命名技巧很强，代码分析时也容易卡壳，不得不分析上下文。<code>auto</code>的使用，更推荐是仅在很小的语块（3句左右）中使用的、类型在语块中明确可见的、机械性重复给重命名带来额外工作量的类型使用<code>auto</code>替代。译文中的<code>would have been abstracted</code>表达的是其概念高度抽象化，无论其实际类型是什么都不影响这类概念的使用方式。举例来说：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=p>...</span>
<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>It</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find</span><span class=p>(</span><span class=n>Vec</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>Vec</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>ElemToFind</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=n>It</span> <span class=o>==</span> <span class=n>Vec</span><span class=p>.</span><span class=n>end</span><span class=p>())</span>
  <span class=k>return</span><span class=p>;</span>
<span class=n>T</span><span class=o>&amp;</span> <span class=n>Elem</span> <span class=o>=</span> <span class=o>*</span><span class=n>It</span>
<span class=p>...</span>
<span class=k>return</span> <span class=n>Elem</span><span class=p>.</span><span class=n>xxx</span> <span class=o>+</span> <span class=n>Elem</span><span class=p>.</span><span class=n>yyy</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p><code>std::vector&lt;T>::iterator It</code>推荐使用<code>auto</code>，<code>It</code>承载的是迭代器的概念，两处使用<code>if (It == Vec.end())</code>是与<code>T</code>类型无关的属于迭代器抽象模型的逻辑算法，<code>T& Elem = *It</code>在简短语块中清晰可见。<code>T& Elem = *It</code>不推荐使用<code>auto</code>，因为下文有若干特定业务的计算逻辑，此处需要保持类型描述清晰，否则需要反向推导直到发现<code>std::find</code>中的<code>Vec</code>的类型。由于对<code>auto</code>使用的判断具有一定的主观性，且依赖于历史开发维护经验，所以若当是否用<code>auto</code>的选择不能快速直观的给出结论时，不要使用<code>auto</code>，少量的啰嗦总强于语意不清。</p><h4 id=beware-unnecessary-copies-with-autohttpllvmorgdocscodingstandardshtmlid29警惕不必要的auto拷贝><a href=http://llvm.org/docs/CodingStandards.html#id29>Beware unnecessary copies with <code>auto</code></a>(警惕不必要的<code>auto</code>拷贝)</h4><p>The convenience of <code>auto</code> makes it easy to forget that its default behavior is a copy. Particularly in range-based <code>for</code>loops, careless copies are expensive.</p><p>【译】<code>auto</code>的易用性使仁恒很容易忘记它的默认行为是拷贝。尤其是在基于范围的<code>for</code>循环中，这种粗心导致的拷贝代价很大。</p><p>As a rule of thumb, use <code>auto &</code> unless you need to copy the result, and use <code>auto *</code> when copying pointers.</p><p>【译】根据经验，除非拷贝结果，否则使用<code>auto &</code>，并使用<code>auto *</code>拷贝指针。</p><p>【注】引用从本质上来说并不是一种对象（虽然编译器可能类似指针实现），没有引用的引用，没有指向引用的指针，也没有引用数组，它是一种别名关系，所以静态类型推导无法识别引用类型，<code>auto</code>使用需要显示区分引用和拷贝便是这个原因。指针是一种数据类型，此处显示拷贝指针所要防范的场景未知，或许仅仅为了和引用保持一致关系。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Typically there&#39;s no reason to copy.
</span><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>Val</span> <span class=p>:</span> <span class=n>Container</span><span class=p>)</span> <span class=p>{</span> <span class=n>observe</span><span class=p>(</span><span class=n>Val</span><span class=p>);</span> <span class=p>}</span>
<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>Val</span> <span class=p>:</span> <span class=n>Container</span><span class=p>)</span> <span class=p>{</span> <span class=n>Val</span><span class=p>.</span><span class=n>change</span><span class=p>();</span> <span class=p>}</span>

<span class=c1>// Remove the reference if you really want a new copy.
</span><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>Val</span> <span class=p>:</span> <span class=n>Container</span><span class=p>)</span> <span class=p>{</span> <span class=n>Val</span><span class=p>.</span><span class=n>change</span><span class=p>();</span> <span class=n>saveSomewhere</span><span class=p>(</span><span class=n>Val</span><span class=p>);</span> <span class=p>}</span>

<span class=c1>// Copy pointers, but make it clear that they&#39;re pointers.
</span><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>*</span><span class=nl>Ptr</span> <span class=p>:</span> <span class=n>Container</span><span class=p>)</span> <span class=p>{</span> <span class=n>observe</span><span class=p>(</span><span class=o>*</span><span class=n>Ptr</span><span class=p>);</span> <span class=p>}</span>
<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>*</span><span class=nl>Ptr</span> <span class=p>:</span> <span class=n>Container</span><span class=p>)</span> <span class=p>{</span> <span class=n>Ptr</span><span class=o>-&gt;</span><span class=n>change</span><span class=p>();</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=beware-of-non-determinism-due-to-ordering-of-pointershttpllvmorgdocscodingstandardshtmlid30警惕指针排序的不确定性><a href=http://llvm.org/docs/CodingStandards.html#id30>Beware of non-determinism due to ordering of pointers</a>(警惕指针排序的不确定性)</h4><p>In general, there is no relative ordering among pointers. As a result, when unordered containers like sets and maps are used with pointer keys the iteration order is undefined. Hence, iterating such containers may result in non-deterministic code generation. While the generated code might not necessarily be “wrong code”, this non-determinism might result in unexpected runtime crashes or simply hard to reproduce bugs on the customer side making it harder to debug and fix.</p><p>【译】通常，指针之间不存在相对顺序。因此，当指针作为集合和映射这样的无序容器的主键时，迭代顺序是未定义的。而且迭代这样的容器可能会导致不确定代码的生成。虽然生成的代码不一定是“错误的代码”，但这种非确定性可能会导致意外的运行时崩溃、或客户发现的错误难以重现，从而使调试和修复变得更加困难。</p><p>As a rule of thumb, in case an ordered result is expected, remember to sort an unordered container before iteration. Or use ordered containers like vector/MapVector/SetVector if you want to iterate pointer keys.</p><p>【译】根据经验，如果需要有序结果，记住在迭代之前对无序容器进行排序。 或者，如果要迭代指针键，使用vector / MapVector / SetVector等有序容器。</p><p>【注】虽然LLVM中存在使用指针作为排序关键字的场景，但无论其对象的排序是否稳定，这种用法本身就违背了诸多原则。例如，赋予指针除标记地址外的另外的职责，违背SOLID中单一职责的设计原则，而此处的迭代主键本应该由对象中的部分或全部成员，或hask、UUID等算法构建，偷懒的嫌疑居多。所以，指针除用于记录对象地址以及传递外，不应该参与其他任何算法与逻辑。</p><h4 id=beware-of-non-deterministic-sorting-order-of-equal-elementshttpllvmorgdocscodingstandardshtmlid31警惕相等对象排序的不确定性><a href=http://llvm.org/docs/CodingStandards.html#id31>Beware of non-deterministic sorting order of equal elements</a>(警惕相等对象排序的不确定性)</h4><p>std::sort uses a non-stable sorting algorithm in which the order of equal elements is not guaranteed to be preserved. Thus using std::sort for a container having equal elements may result in non-determinstic behavior. To uncover such instances of non-determinism, LLVM has introduced a new llvm::sort wrapper function. For an EXPENSIVE_CHECKS build this will randomly shuffle the container before sorting. As a rule of thumb, always make sure to use llvm::sort instead of std::sort.</p><p>【译】std :: sort使用了非稳定排序算法，它不保证相等元素的顺序。 因此，对具有相等成员的容器使用std :: sort可能导致不确定性行为。 为了解决这种不确定情况，LLVM引入了一个新的llvm :: sort函数封装。 对于EXPENSIVE_CHECKS构建，这将在排序之前随机地移动容器。 根据经验，始终确保使用llvm :: sort而不是std :: sort。</p><h2 id=style-issueshttpllvmorgdocscodingstandardshtmlid32格式><a href=http://llvm.org/docs/CodingStandards.html#id32>Style Issues</a>(格式)</h2><h3 id=the-high-level-issueshttpllvmorgdocscodingstandardshtmlid33高级主题><a href=http://llvm.org/docs/CodingStandards.html#id33>The High-Level Issues</a>(高级主题)</h3><h4 id=self-contained-headershttpllvmorgdocscodingstandardshtmlid34自包含的头文件><a href=http://llvm.org/docs/CodingStandards.html#id34>Self-contained Headers</a>(自包含的头文件)</h4><p>Header files should be self-contained (compile on their own) and end in .h. Non-header files that are meant for inclusion should end in .inc and be used sparingly.</p><p>【译】头文件应该自包含（独立编译），并以.h作为文件扩展名。非头文件但也用于被包含的，应该谨慎使用，并以.inc作为文件扩展名。</p><p>All header files should be self-contained. Users and refactoring tools should not have to adhere to special conditions to include the header. Specifically, a header should have header guards and include all other headers it needs.</p><p>【译】所有头文件都应该自包含。使用者和重构工具不应该因为某些特殊的状况来包含头文件。具体而言，头文件应该包含标题头保护以及它所必须的其他头文件。</p><p>There are rare cases where a file designed to be included is not self-contained. These are typically intended to be included at unusual locations, such as the middle of another file. They might not use header guards, and might not include their prerequisites. Name such files with the .inc extension. Use sparingly, and prefer self-contained headers when possible.</p><p>【译】有极少的情况，一个文件会被设计成被包含但却不自包含。这些通常被包含在特殊的位置，例如另一个文件的中间位置。 他们可能不使用标题保护，可能不包括他们的依赖。 使用.inc扩展名命名此类文件。 谨慎使用，并尽可能选择自包含的头文件。</p><p>In general, a header should be implemented by one or more <code>.cpp</code> files. Each of these <code>.cpp</code> files should include the header that defines their interface first. This ensures that all of the dependences of the header have been properly added to the header itself, and are not implicit. System headers should be included after user headers for a translation unit.</p><p>【译】通常，头文件实现在一个或多个<code>.cpp</code>文件中。每个头文件都应该包含此头文件，并首先定义相关接口。这可以确保头文件的所有依赖都已正确的被添加到开头，并且不是隐式的。在一个编译单元中，系统头文件应该包含在用户头文件之后。</p><h4 id=library-layeringhttpllvmorgdocscodingstandardshtmlid35库分层><a href=http://llvm.org/docs/CodingStandards.html#id35>Library Layering</a>(库分层)</h4><p>A directory of header files (for example <code>include/llvm/Foo</code>) defines a library (<code>Foo</code>). Dependencies between libraries are defined by the <code>LLVMBuild.txt</code> file in their implementation (<code>lib/Foo</code>). One library (both its headers and implementation) should only use things from the libraries listed in its dependencies.</p><p>【译】一个头文件目录（如<code>include/llvm/Foo</code>）定义了一个库（<code>Foo</code>）。库之间的依赖关系在实现（lib / Foo）目录下的<code>LLVMBuild.txt</code>文件中定义。 一个库（头和实现）应该只使用其依赖库中的东西。</p><p>Some of this constraint can be enforced by classic Unix linkers (Mac & Windows linkers, as well as lld, do not enforce this constraint). A Unix linker searches left to right through the libraries specified on its command line and never revisits a library. In this way, no circular dependencies between libraries can exist.</p><p>【译】一些约束可以由经典的Unix链接器强制执行（Mac和Windows链接器，以及lld，不强制执行此约束）。 Unix链接器从左到右搜索其命令行中指定的库，不会再重新访问一个库。 这样，库之间就不可能循环依赖了。</p><p>This doesn’t fully enforce all inter-library dependencies, and importantly doesn’t enforce header file circular dependencies created by inline functions. A good way to answer the “is this layered correctly” would be to consider whether a Unix linker would succeed at linking the program if all inline functions were defined out-of-line. (& for all valid orderings of dependencies - since linking resolution is linear, it’s possible that some implicit dependencies can sneak through: A depends on B and C, so valid orderings are “C B A” or “B C A”, in both cases the explicit dependencies come before their use. But in the first case, B could still link successfully if it implicitly depended on C, or the opposite in the second case)</p><p>【译】这并不会强制所有库间的依赖关系，并且重要的是，不会强制执行内联函数引起的头文件循环依赖关系。 回答“正确分层”的一个好方法是，考虑如果所有内联函数都定义成外联，Unix链接器是否能成功链接程序。 （对于依赖关系的所有有效排序 - 因为链接决议是线性的，所以有可能即使存在某些隐式依赖关系也可以链接通过：A依赖于B和C，因此有效排序是“CBA”或“BCA”，这两种情况下，显式依赖关系都在它们使用之前确定。但在第一种情况下，如果B隐式依赖于C的话，B仍然可以链接成功，或者反过来在第二种情况下。）</p><h4 id=include-as-little-as-possiblehttpllvmorgdocscodingstandardshtmlid36头文件最小依赖><a href=http://llvm.org/docs/CodingStandards.html#id36><code>#include</code> as Little as Possible</a>(头文件最小依赖)</h4><p><code>#include</code> hurts compile time performance. Don’t do it unless you have to, especially in header files.</p><p>【译】<code>#include</code>会影响编译时间方面的性能，除非必须，否则不要新增<code>#include</code>，尤其是在头文件中。</p><p>But wait! Sometimes you need to have the definition of a class to use it, or to inherit from it. In these cases go ahead and <code>#include</code> that header file. Be aware however that there are many cases where you don’t need to have the full definition of a class. If you are using a pointer or reference to a class, you don’t need the header file. If you are simply returning a class instance from a prototyped function or method, you don’t need it. In fact, for most cases, you simply don’t need the definition of a class. And not <code>#include</code>ing speeds up compilation.</p><p>【译】可是等等！有时需要类的定义来使用它，或者继承它，在这些情况下，<code>#include</code>对应的头文件。但需要注意，有很多场景并不需要类的完整定义。如果正在使用一个类的指针或引用，则不需要包含对应的头文件。如果简单的从一个原型方法或函数返回一个类实例，也不需要。实际上，大多数场景下，并不需要一个类的定义，如果不<code>#include</code>，那将提升编译的速度。</p><p>It is easy to try to go too overboard on this recommendation, however. You <strong>must</strong> include all of the header files that you are using — you can include them either directly or indirectly through another header file. To make sure that you don’t accidentally forget to include a header file in your module header, make sure to include your module header <strong>first</strong> in the implementation file (as mentioned above). This way there won’t be any hidden dependencies that you’ll find out about later.</p><p>【译】然而，很容易过度解读这个建议。必须包含正在使用的所有头文件——可以直接包含，也可以通过其他头文件间接包含。为了确保不会在模块头文件中遗漏一个头文件，保证在实现文件中首先包含模块头文件（前面已提到），这样任何隐藏的依赖关系都不会存在。</p><h4 id=keep-internal-headers-privatehttpllvmorgdocscodingstandardshtmlid37保持内部头文件私有><a href=http://llvm.org/docs/CodingStandards.html#id37>Keep “Internal” Headers Private</a>(保持"内部"头文件私有)</h4><p>Many modules have a complex implementation that causes them to use more than one implementation (<code>.cpp</code>) file. It is often tempting to put the internal communication interface (helper classes, extra functions, etc) in the public module header file. Don’t do this!</p><p>【译】有些模块实现复杂，以至于需要多个实现文件（<code>.cpp</code>）。这经常会诱导将内部接口（辅助类、额外的方法等等）放到公共的模块头文件中。但不要这么做。</p><p>If you really need to do something like this, put a private header file in the same directory as the source files, and include it locally. This ensures that your private interface remains private and undisturbed by outsiders.</p><p>【译】如果确实需要这样做，在源文件同目录下加一个私有文头文件，并在当前目录下包含它。这确保了私有接口依然私有，而且不会被外部干扰。</p><blockquote><p>Note（注意）</p><p>It’s okay to put extra implementation methods in a public class itself. Just make them private (or protected) and all is well.</p><p>【译】将额外的实现函数放在它的公有类中是可以的，只要设置成私有（或集成）的就成。</p></blockquote><h4 id=use-early-exits-and-continue-to-simplify-codehttpllvmorgdocscodingstandardshtmlid38提前使用退出和continue来简化代码><a href=http://llvm.org/docs/CodingStandards.html#id38>Use Early Exits and <code>continue</code> to Simplify Code</a>(提前使用退出和<code>continue</code>来简化代码)</h4><p>When reading code, keep in mind how much state and how many previous decisions have to be remembered by the reader to understand a block of code. Aim to reduce indentation where possible when it doesn’t make it more difficult to understand the code. One great way to do this is by making use of early exits and the <code>continue</code> keyword in long loops. As an example of using an early exit from a function, consider this “bad” code:</p><p>【译】阅读代码时，记录下读者必须记住多少个状态、多少个前置判断才能理解一段代码。目的是，只要代码不会变的更难理解，尽可能去减少缩进。达成这个目的，有个很好的方法是提前退出，以及长循环中使用<code>continue</code>关键字。举一个函数提前退出的例子，思考下面的"坏"代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Value</span> <span class=o>*</span><span class=nf>doSomething</span><span class=p>(</span><span class=n>Instruction</span> <span class=o>*</span><span class=n>I</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>I</span><span class=o>-&gt;</span><span class=n>isTerminator</span><span class=p>()</span> <span class=o>&amp;&amp;</span>
      <span class=n>I</span><span class=o>-&gt;</span><span class=n>hasOneUse</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>doOtherThing</span><span class=p>(</span><span class=n>I</span><span class=p>))</span> <span class=p>{</span>
    <span class=p>...</span> <span class=n>some</span> <span class=kt>long</span> <span class=n>code</span> <span class=p>....</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>This code has several problems if the body of the <code>'if'</code> is large. When you’re looking at the top of the function, it isn’t immediately clear that this <em>only</em> does interesting things with non-terminator instructions, and only applies to things with the other predicates. Second, it is relatively difficult to describe (in comments) why these predicates are important because the <code>if</code> statement makes it difficult to lay out the comments. Third, when you’re deep within the body of the code, it is indented an extra level. Finally, when reading the top of the function, it isn’t clear what the result is if the predicate isn’t true; you have to read to the end of the function to know that it returns null.</p><p>【译】如果<code>if</code>的内容很多，这段代码就会出现很多问题。当查看这个函数头时，它只对非结束指令做了些有意思的事情，以及只做了一些判断，这并不会一下子就很清晰。第二点，由于<code>if</code>语句使添加注释变得困难，这就相对很难去描述（注释）为什么这些判断很重要。第三点，当深入到这段代码的内部时，缩进会再增加一个级别。最终，当阅读函数头时，如果判断不正确，搞不清楚结果会是什么；必须读到函数尾才知道返回<code>null</code>。</p><p>It is much preferred to format the code like this:</p><p>【译】最好像这样组织代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Value</span> <span class=o>*</span><span class=nf>doSomething</span><span class=p>(</span><span class=n>Instruction</span> <span class=o>*</span><span class=n>I</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Terminators never need &#39;something&#39; done to them because ...
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>I</span><span class=o>-&gt;</span><span class=n>isTerminator</span><span class=p>())</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

  <span class=c1>// We conservatively avoid transforming instructions with multiple uses
</span><span class=c1></span>  <span class=c1>// because goats like cheese.
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>I</span><span class=o>-&gt;</span><span class=n>hasOneUse</span><span class=p>())</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

  <span class=c1>// This is really just here for example.
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>doOtherThing</span><span class=p>(</span><span class=n>I</span><span class=p>))</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

  <span class=p>...</span> <span class=n>some</span> <span class=kt>long</span> <span class=n>code</span> <span class=p>....</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>This fixes these problems. A similar problem frequently happens in <code>for</code> loops. A silly example is something like this:</p><p>【译】这就解决了这些问题。类似的问题也经常发生在<code>for</code>循环里，有个比较笨的例子就像这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>for</span> <span class=p>(</span><span class=n>Instruction</span> <span class=o>&amp;</span><span class=nl>I</span> <span class=p>:</span> <span class=n>BB</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=o>*</span><span class=n>BO</span> <span class=o>=</span> <span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>BinaryOperator</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>I</span><span class=p>))</span> <span class=p>{</span>
    <span class=n>Value</span> <span class=o>*</span><span class=n>LHS</span> <span class=o>=</span> <span class=n>BO</span><span class=o>-&gt;</span><span class=n>getOperand</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
    <span class=n>Value</span> <span class=o>*</span><span class=n>RHS</span> <span class=o>=</span> <span class=n>BO</span><span class=o>-&gt;</span><span class=n>getOperand</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>LHS</span> <span class=o>!=</span> <span class=n>RHS</span><span class=p>)</span> <span class=p>{</span>
      <span class=p>...</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>When you have very, very small loops, this sort of structure is fine. But if it exceeds more than 10-15 lines, it becomes difficult for people to read and understand at a glance. The problem with this sort of code is that it gets very nested very quickly. Meaning that the reader of the code has to keep a lot of context in their brain to remember what is going immediately on in the loop, because they don’t know if/when the <code>if</code> conditions will have <code>else</code>s etc. It is strongly preferred to structure the loop like this:</p><p>【译】如果循环体非常非常小，这种结构是可行的。但如果超过10-15行，这很难让人一下子就能读懂。这类代码的问题在于它立刻做很多的嵌套。这意味着，这段代码的读者必须在大脑中保留大量的上下文才能理解循环正在做什么，因为它们不知道是否、何时这个<code>if</code>条件会有个<code>else</code>等等。强烈建议像这样组织循环：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>for</span> <span class=p>(</span><span class=n>Instruction</span> <span class=o>&amp;</span><span class=nl>I</span> <span class=p>:</span> <span class=n>BB</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>auto</span> <span class=o>*</span><span class=n>BO</span> <span class=o>=</span> <span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>BinaryOperator</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>I</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>BO</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>

  <span class=n>Value</span> <span class=o>*</span><span class=n>LHS</span> <span class=o>=</span> <span class=n>BO</span><span class=o>-&gt;</span><span class=n>getOperand</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
  <span class=n>Value</span> <span class=o>*</span><span class=n>RHS</span> <span class=o>=</span> <span class=n>BO</span><span class=o>-&gt;</span><span class=n>getOperand</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>LHS</span> <span class=o>==</span> <span class=n>RHS</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>

  <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>This has all the benefits of using early exits for functions: it reduces nesting of the loop, it makes it easier to describe why the conditions are true, and it makes it obvious to the reader that there is no <code>else</code> coming up that they have to push context into their brain for. If a loop is large, this can be a big understandability win.</p><p>【译】这个例子就体现了函数提前退出的优势：减少了循环嵌套；更容易去解释为什么条件是正确；显而易见的告诉读者没有<code>else</code>分支了，无须再为此记住上下文。如果循环很大，那这一定是可理解性的大成功。</p><h4 id=dont-use-else-after-a-returnhttpllvmorgdocscodingstandardshtmlid39禁止return后使用else><a href=http://llvm.org/docs/CodingStandards.html#id39>Don’t use <code>else</code> after a <code>return</code></a>(禁止<code>return</code>后使用<code>else</code>)</h4><p>For similar reasons above (reduction of indentation and easier reading), please do not use <code>'else'</code> or <code>'else if'</code> after something that interrupts control flow — like <code>return</code>, <code>break</code>, <code>continue</code>, <code>goto</code>, etc. For example, this is <em>bad</em>:</p><p>【译】和上述原因类似（减少缩进、提升可阅读性），请不要在中断控制流的语句后使用<code>else</code>或<code>else if</code>——例如<code>return</code>、 <code>break</code>、 <code>continue</code>、 <code>goto</code>等。举例来说，这样是不好的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>case</span> <span class=sc>&#39;J&#39;</span><span class=o>:</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>Signed</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>Type</span> <span class=o>=</span> <span class=n>Context</span><span class=p>.</span><span class=n>getsigjmp_bufType</span><span class=p>();</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>Type</span><span class=p>.</span><span class=n>isNull</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>Error</span> <span class=o>=</span> <span class=n>ASTContext</span><span class=o>::</span><span class=n>GE_Missing_sigjmp_buf</span><span class=p>;</span>
      <span class=k>return</span> <span class=nf>QualType</span><span class=p>();</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>Type</span> <span class=o>=</span> <span class=n>Context</span><span class=p>.</span><span class=n>getjmp_bufType</span><span class=p>();</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>Type</span><span class=p>.</span><span class=n>isNull</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>Error</span> <span class=o>=</span> <span class=n>ASTContext</span><span class=o>::</span><span class=n>GE_Missing_jmp_buf</span><span class=p>;</span>
      <span class=k>return</span> <span class=nf>QualType</span><span class=p>();</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>It is better to write it like this:</p><p>【译】最好这样写。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>case</span> <span class=sc>&#39;J&#39;</span><span class=o>:</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>Signed</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>Type</span> <span class=o>=</span> <span class=n>Context</span><span class=p>.</span><span class=n>getsigjmp_bufType</span><span class=p>();</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>Type</span><span class=p>.</span><span class=n>isNull</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>Error</span> <span class=o>=</span> <span class=n>ASTContext</span><span class=o>::</span><span class=n>GE_Missing_sigjmp_buf</span><span class=p>;</span>
      <span class=k>return</span> <span class=nf>QualType</span><span class=p>();</span>
    <span class=p>}</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>Type</span> <span class=o>=</span> <span class=n>Context</span><span class=p>.</span><span class=n>getjmp_bufType</span><span class=p>();</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>Type</span><span class=p>.</span><span class=n>isNull</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>Error</span> <span class=o>=</span> <span class=n>ASTContext</span><span class=o>::</span><span class=n>GE_Missing_jmp_buf</span><span class=p>;</span>
      <span class=k>return</span> <span class=nf>QualType</span><span class=p>();</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>break</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>Or better yet (in this case) as:</p><p>【译】或者，这个例子更好的写法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>case</span> <span class=sc>&#39;J&#39;</span><span class=o>:</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>Signed</span><span class=p>)</span>
    <span class=n>Type</span> <span class=o>=</span> <span class=n>Context</span><span class=p>.</span><span class=n>getsigjmp_bufType</span><span class=p>();</span>
  <span class=k>else</span>
    <span class=n>Type</span> <span class=o>=</span> <span class=n>Context</span><span class=p>.</span><span class=n>getjmp_bufType</span><span class=p>();</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>Type</span><span class=p>.</span><span class=n>isNull</span><span class=p>())</span> <span class=p>{</span>
    <span class=n>Error</span> <span class=o>=</span> <span class=n>Signed</span> <span class=o>?</span> <span class=n>ASTContext</span><span class=o>::</span><span class=nl>GE_Missing_sigjmp_buf</span> <span class=p>:</span>
                     <span class=n>ASTContext</span><span class=o>::</span><span class=n>GE_Missing_jmp_buf</span><span class=p>;</span>
    <span class=k>return</span> <span class=nf>QualType</span><span class=p>();</span>
  <span class=p>}</span>
  <span class=k>break</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>The idea is to reduce indentation and the amount of code you have to keep track of when reading the code.</p><p>【译】这个思路主要是减少缩进，以及减少阅读时需要跟踪的代码量。</p><h4 id=turn-predicate-loops-into-predicate-functionshttpllvmorgdocscodingstandardshtmlid40将判断循环变为判断函数><a href=http://llvm.org/docs/CodingStandards.html#id40>Turn Predicate Loops into Predicate Functions</a>(将判断循环变为判断函数)</h4><p>It is very common to write small loops that just compute a boolean value. There are a number of ways that people commonly write these, but an example of this sort of thing is:</p><p>【译】写个小循环来计算一个布尔值是很常见的。通常会有多种方式来写，但其中一种示例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>bool</span> <span class=n>FoundFoo</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=n>I</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>E</span> <span class=o>=</span> <span class=n>BarList</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>I</span> <span class=o>!=</span> <span class=n>E</span><span class=p>;</span> <span class=o>++</span><span class=n>I</span><span class=p>)</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>BarList</span><span class=p>[</span><span class=n>I</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>isFoo</span><span class=p>())</span> <span class=p>{</span>
    <span class=n>FoundFoo</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
    <span class=k>break</span><span class=p>;</span>
  <span class=p>}</span>

<span class=k>if</span> <span class=p>(</span><span class=n>FoundFoo</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>This sort of code is awkward to write, and is almost always a bad sign. Instead of this sort of loop, we strongly prefer to use a predicate function (which may be <a href=http://llvm.org/docs/CodingStandards.html#static>static</a>) that uses <a href=http://llvm.org/docs/CodingStandards.html#early-exits>early exits</a> to compute the predicate. We prefer the code to be structured like this:</p><p>【译】这类代码写起来很笨拙，而且几乎就不是个好的写法。除了这类循环，我们强烈推荐使用提前退出来实现这个判断函数（可能是静态函数）。我们期望代码组织成这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// \returns true if the specified list has an element that is a foo.
</span><span class=c1></span><span class=k>static</span> <span class=kt>bool</span> <span class=nf>containsFoo</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Bar</span><span class=o>*&gt;</span> <span class=o>&amp;</span><span class=n>List</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=n>I</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>E</span> <span class=o>=</span> <span class=n>List</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>I</span> <span class=o>!=</span> <span class=n>E</span><span class=p>;</span> <span class=o>++</span><span class=n>I</span><span class=p>)</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>List</span><span class=p>[</span><span class=n>I</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>isFoo</span><span class=p>())</span>
      <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
  <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
<span class=p>}</span>
<span class=p>...</span>

<span class=k>if</span> <span class=p>(</span><span class=n>containsFoo</span><span class=p>(</span><span class=n>BarList</span><span class=p>))</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>There are many reasons for doing this: it reduces indentation and factors out code which can often be shared by other code that checks for the same predicate. More importantly, it <em>forces you to pick a name</em> for the function, and forces you to write a comment for it. In this silly example, this doesn’t add much value. However, if the condition is complex, this can make it a lot easier for the reader to understand the code that queries for this predicate. Instead of being faced with the in-line details of how we check to see if the BarList contains a foo, we can trust the function name and continue reading with better locality.</p><p>【译】有很多理由这样设计：减少缩进；提取公共代码，这些代码可以被具有相同判断条件的其他检查代码复用。更重要的是，这会强制去给函数挑个名字，以及强制写注释。在这个笨例子中，并没有体现太多的价差。但是，如果条件很复杂，这会让读者更容易去理解这段代码。我们可以信任这个函数名称，并更好的在当前位置继续阅读，而不用去面对BarList是否包含foo这样内联的检查细节。</p><h3 id=the-low-level-issueshttpllvmorgdocscodingstandardshtmlid41初级主题><a href=http://llvm.org/docs/CodingStandards.html#id41>The Low-Level Issues</a>(初级主题)</h3><h4 id=name-types-functions-variables-and-enumerators-properlyhttpllvmorgdocscodingstandardshtmlid42类型函数变量枚举的合理命名><a href=http://llvm.org/docs/CodingStandards.html#id42>Name Types, Functions, Variables, and Enumerators Properly</a>(类型、函数、变量、枚举的合理命名)</h4><p>Poorly-chosen names can mislead the reader and cause bugs. We cannot stress enough how important it is to use <em>descriptive</em> names. Pick names that match the semantics and role of the underlying entities, within reason. Avoid abbreviations unless they are well known. After picking a good name, make sure to use consistent capitalization for the name, as inconsistency requires clients to either memorize the APIs or to look it up to find the exact spelling.</p><p>【译】不恰当的名称会误导读者并引发错误。我们几乎无法再强调使用描述性的名字是多么重要。在合理的范围内，选择与基础实体语义和角色相匹配的名称。除非非常常用，否则不要使用缩写。选择一个好名字后，确保对名称使用一致的大小写，因为不一致的大小写需要调用者要么记住API或者去查找确切的拼写。</p><p>In general, names should be in camel case (e.g. <code>TextFileReader</code> and <code>isLValue()</code>). Different kinds of declarations have different rules:</p><p>【译】通常，名称应遵从驼峰命名法（如<code>TextFileReader</code>和<code>isLValue()</code>），不同类型的声明有不同的规则：</p><ul><li><strong>Type names</strong> (including classes, structs, enums, typedefs, etc) should be nouns and start with an upper-case letter (e.g. <code>TextFileReader</code>).</li></ul><p>【译】类型名称（包括类、结构体、枚举、typedef等）应该是名词，并以大写字母开头（如<code>TextFileReader</code>）。</p><ul><li><strong>Variable names</strong> should be nouns (as they represent state). The name should be camel case, and start with an upper case letter (e.g. <code>Leader</code> or <code>Boats</code>).</li></ul><p>【译】变量名称应该是名词（因为它们代表状态）。名称应该使用驼峰命名法，并以大写字母开头（如<code>Leader</code>或<code>Boats</code>）。</p><ul><li><strong>Function names</strong> should be verb phrases (as they represent actions), and command-like function should be imperative. The name should be camel case, and start with a lower case letter (e.g. <code>openFile()</code> or <code>isFoo()</code>).</li></ul><p>【译】函数名称应该是动词短语（因为它们代表动作），命令式函数应该是祈使句。名称应该使用驼峰命名法，并以小写字母开头（如<code>openFile()</code>或<code>isFoo()</code>）。</p><ul><li><strong>Enum declarations</strong> (e.g. <code>enum Foo {...}</code>) are types, so they should follow the naming conventions for types. A common use for enums is as a discriminator for a union, or an indicator of a subclass. When an enum is used for something like this, it should have a <code>Kind</code> suffix (e.g. <code>ValueKind</code>).</li></ul><p>【译】枚举声明（如<code>enum Foo {…}</code>）是类型，所以它们应该遵循类型的命名规则。一个枚举的通常用法是联合体的鉴别符或子类的指示符。当枚举用于类似的场景时，它应该有一个<code>Kind</code>后缀（如<code>ValueKind</code>）。</p><ul><li><strong>Enumerators</strong> (e.g. <code>enum { Foo, Bar }</code>) and <strong>public member variables</strong> should start with an upper-case letter, just like types. Unless the enumerators are defined in their own small namespace or inside a class, enumerators should have a prefix corresponding to the enum declaration name. For example, <code>enum ValueKind { ...};</code> may contain enumerators like <code>VK_Argument</code>, <code>VK_BasicBlock</code>, etc. Enumerators that are just convenience constants are exempt from the requirement for a prefix. For instance:</li></ul><p>【译】枚举成员（如<code>enum { Foo, Bar }</code>）和公有成员变量应该以大写字母打头，就像类型。除非枚举成员定义在它们自己的小命名空间或类内部，否则枚举成员应该有一个和枚举名称对应的前缀。例如，<code>enum ValueKind { ...};</code>可以包含枚举成员，如<code>VK_Argument</code>、<code>VK_BasicBlock</code>等。 仅为了便利而定义的枚举常量不受前缀要求的约束，举例来说：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>enum</span> <span class=p>{</span>
  <span class=n>MaxSize</span> <span class=o>=</span> <span class=mi>42</span><span class=p>,</span>
  <span class=n>Density</span> <span class=o>=</span> <span class=mi>12</span>
<span class=p>};</span>
</code></pre></td></tr></table></div></div><p>As an exception, classes that mimic STL classes can have member names in STL’s style of lower-case words separated by underscores (e.g. <code>begin()</code>, <code>push_back()</code>, and <code>empty()</code>). Classes that provide multiple iterators should add a singular prefix to <code>begin()</code> and <code>end()</code> (e.g. <code>global_begin()</code> and <code>use_begin()</code>).</p><p>【译】例外，模仿STL的类可以拥有STL风格的成员名称：以下划线分隔的全小写单词（如<code>begin()</code>、<code>push_back()</code>和<code>empty()</code>）。提供多种迭代器的类需要为<code>begin()</code>和<code>end()</code>添加前缀（如<code>global_begin()</code>和<code>use_begin()</code>）。</p><p>Here are some examples of good and bad names:</p><p>【译】以下是一些好命名和不好命名的示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>VehicleMaker</span> <span class=p>{</span>
  <span class=p>...</span>
  <span class=n>Factory</span><span class=o>&lt;</span><span class=n>Tire</span><span class=o>&gt;</span> <span class=n>F</span><span class=p>;</span>            <span class=c1>// Bad -- abbreviation and non-descriptive.
</span><span class=c1></span>  <span class=n>Factory</span><span class=o>&lt;</span><span class=n>Tire</span><span class=o>&gt;</span> <span class=n>Factory</span><span class=p>;</span>      <span class=c1>// Better.
</span><span class=c1></span>  <span class=n>Factory</span><span class=o>&lt;</span><span class=n>Tire</span><span class=o>&gt;</span> <span class=n>TireFactory</span><span class=p>;</span>  <span class=c1>// Even better -- if VehicleMaker has more than one
</span><span class=c1></span>                              <span class=c1>// kind of factories.
</span><span class=c1></span><span class=p>};</span>

<span class=n>Vehicle</span> <span class=nf>makeVehicle</span><span class=p>(</span><span class=n>VehicleType</span> <span class=n>Type</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>VehicleMaker</span> <span class=n>M</span><span class=p>;</span>                         <span class=c1>// Might be OK if having a short life-span.
</span><span class=c1></span>  <span class=n>Tire</span> <span class=n>Tmp1</span> <span class=o>=</span> <span class=n>M</span><span class=p>.</span><span class=n>makeTire</span><span class=p>();</span>               <span class=c1>// Bad -- &#39;Tmp1&#39; provides no information.
</span><span class=c1></span>  <span class=n>Light</span> <span class=n>Headlight</span> <span class=o>=</span> <span class=n>M</span><span class=p>.</span><span class=n>makeLight</span><span class=p>(</span><span class=s>&#34;head&#34;</span><span class=p>);</span>  <span class=c1>// Good -- descriptive.
</span><span class=c1></span>  <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=assert-liberallyhttpllvmorgdocscodingstandardshtmlid43灵活的使用断言><a href=http://llvm.org/docs/CodingStandards.html#id43>Assert Liberally</a>(灵活的使用断言)</h4><p>Use the “<code>assert</code>” macro to its fullest. Check all of your preconditions and assumptions, you never know when a bug (not necessarily even yours) might be caught early by an assertion, which reduces debugging time dramatically. The “<code>&lt;cassert></code>” header file is probably already included by the header files you are using, so it doesn’t cost anything to use it.</p><p>【译】充分利用<code>assert</code>宏。检查所有前提条件和假设，因为你永远无法知道在什么时候一个问题（不一定是自己导致的）会被断言提前捕获，这会大大的减少调试时间。<code>&lt;assert></code>已经被正在使用的头文件所包含，所以使用的话不需要再有额外的动作。</p><p>To further assist with debugging, make sure to put some kind of error message in the assertion statement, which is printed if the assertion is tripped. This helps the poor debugger make sense of why an assertion is being made and enforced, and hopefully what to do about it. Here is one complete example:</p><p>【译】为进一步辅助调试，确保在断言语句中添加某种错误信息，如果断言被触发，则会打印该错误信息。这有助于缺乏经验的调试者理解为什么要定并强制执行一个断言，并期望如何去处理它。下面是个完整的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=kr>inline</span> <span class=n>Value</span> <span class=o>*</span><span class=nf>getOperand</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>I</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>I</span> <span class=o>&lt;</span> <span class=n>Operands</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;getOperand() out of range!&#34;</span><span class=p>);</span>
  <span class=k>return</span> <span class=n>Operands</span><span class=p>[</span><span class=n>I</span><span class=p>];</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Here are more examples:</p><p>【译】更多例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>assert</span><span class=p>(</span><span class=n>Ty</span><span class=o>-&gt;</span><span class=n>isPointerType</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;Can&#39;t allocate a non-pointer type!&#34;</span><span class=p>);</span>

<span class=n>assert</span><span class=p>((</span><span class=n>Opcode</span> <span class=o>==</span> <span class=n>Shl</span> <span class=o>||</span> <span class=n>Opcode</span> <span class=o>==</span> <span class=n>Shr</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;ShiftInst Opcode invalid!&#34;</span><span class=p>);</span>

<span class=n>assert</span><span class=p>(</span><span class=n>idx</span> <span class=o>&lt;</span> <span class=n>getNumSuccessors</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;Successor # out of range!&#34;</span><span class=p>);</span>

<span class=n>assert</span><span class=p>(</span><span class=n>V1</span><span class=p>.</span><span class=n>getType</span><span class=p>()</span> <span class=o>==</span> <span class=n>V2</span><span class=p>.</span><span class=n>getType</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;Constant types must be identical!&#34;</span><span class=p>);</span>

<span class=n>assert</span><span class=p>(</span><span class=n>isa</span><span class=o>&lt;</span><span class=n>PHINode</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Succ</span><span class=o>-&gt;</span><span class=n>front</span><span class=p>())</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;Only works on PHId BBs!&#34;</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>You get the idea.</p><p>【译】这下你应该懂了。</p><p>In the past, asserts were used to indicate a piece of code that should not be reached. These were typically of the form:</p><p>【译】过去，断言用于表示不可达的代码片段，通常形式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>assert</span><span class=p>(</span><span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;Invalid radix for integer literal&#34;</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>This has a few issues, the main one being that some compilers might not understand the assertion, or warn about a missing return in builds where assertions are compiled out.</p><p>【译】这存在一些问题，主要的一个是一些编译器无法解析断言，或编译时断言被编译掉了，会提示缺少返回值。</p><p>Today, we have something much better: <code>llvm_unreachable</code>:</p><p>如今我们有更好的选择：<code>llvm_unreachable</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>llvm_unreachable</span><span class=p>(</span><span class=s>&#34;Invalid radix for integer literal&#34;</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>When assertions are enabled, this will print the message if it’s ever reached and then exit the program. When assertions are disabled (i.e. in release builds), <code>llvm_unreachable</code> becomes a hint to compilers to skip generating code for this branch. If the compiler does not support this, it will fall back to the “abort” implementation.</p><p>【译】启用断言后，如果运行到这段代码，就会打印这段信息并退出程序。禁用断言后（如编译发布版本），<code>llvm_unreachable</code>成为编译器跳过为此分支生成代码的提示。如果编译器不支持该特性，它将回退成<code>abort</code>实现。</p><p>Neither assertions or <code>llvm_unreachable</code> will abort the program on a release build. If the error condition can be triggered by user input then the recoverable error mechanism described in <a href=http://llvm.org/docs/ProgrammersManual.html>LLVM Programmer’s Manual</a> should be used instead. In cases where this is not practical, <code>report_fatal_error</code> may be used.</p><p>【译】在发布版本中，无论断言还是<code>llvm_unreachable</code>都将中止程序。如果出错条件可以由用户输入触发，则应使用LLVM程序员手册中描述的可恢复错误机制。 如果这不可行，可以使用report_fatal_error。</p><p>Another issue is that values used only by assertions will produce an “unused value” warning when assertions are disabled. For example, this code will warn:</p><p>【译】还有个问题，如果禁用断言，仅由断言使用的值将产生“未使用的值”警告。例如，以下代码将告警：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>unsigned</span> <span class=n>Size</span> <span class=o>=</span> <span class=n>V</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
<span class=n>assert</span><span class=p>(</span><span class=n>Size</span> <span class=o>&gt;</span> <span class=mi>42</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;Vector smaller than it should be&#34;</span><span class=p>);</span>

<span class=kt>bool</span> <span class=n>NewToSet</span> <span class=o>=</span> <span class=n>Myset</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>Value</span><span class=p>);</span>
<span class=n>assert</span><span class=p>(</span><span class=n>NewToSet</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;The value shouldn&#39;t be in the set yet&#34;</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>These are two interesting different cases. In the first case, the call to <code>V.size()</code> is only useful for the assert, and we don’t want it executed when assertions are disabled. Code like this should move the call into the assert itself. In the second case, the side effects of the call must happen whether the assert is enabled or not. In this case, the value should be cast to void to disable the warning. To be specific, it is preferred to write the code like this:</p><p>【译】这两个例子很有意思。第一个例子中，对<code>V.size()</code>的调用仅对断言有效，我们并不希望在禁用断言的情况下执行。像这样的代码应该把调用移到断言内。第二个例子中，无论断言是否启用，调用的副作用都会产生。这种情况下，应将值转换为void来禁用告警。具体来说，最好这样编码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>assert</span><span class=p>(</span><span class=n>V</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>42</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;Vector smaller than it should be&#34;</span><span class=p>);</span>

<span class=kt>bool</span> <span class=n>NewToSet</span> <span class=o>=</span> <span class=n>Myset</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>Value</span><span class=p>);</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=n>NewToSet</span><span class=p>;</span>
<span class=n>assert</span><span class=p>(</span><span class=n>NewToSet</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;The value shouldn&#39;t be in the set yet&#34;</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><h4 id=do-not-use-using-namespace-stdhttpllvmorgdocscodingstandardshtmlid44禁用using-namespace-std><a href=http://llvm.org/docs/CodingStandards.html#id44>Do Not Use <code>using namespace std</code></a>(禁用<code>using namespace std</code>)</h4><p>In LLVM, we prefer to explicitly prefix all identifiers from the standard namespace with an “<code>std::</code>” prefix, rather than rely on “<code>using namespace std;</code>”.</p><p>【译】在LLVM中，我们更喜欢使用“std ::”前缀显式地为标准命名空间中的所有标识符添加前缀，而不是依赖于“using namespace std;”。</p><p>In header files, adding a <code>'using namespace XXX'</code> directive pollutes the namespace of any source file that <code>#include</code>s the header. This is clearly a bad thing.</p><p>【译】在头文件中，使用<code>'using namespace XXX'</code>会污染任何<code>#include</code>该头文件的源文件命名空间。 这显然不好。</p><p>In implementation files (e.g. <code>.cpp</code> files), the rule is more of a stylistic rule, but is still important. Basically, using explicit namespace prefixes makes the code <strong>clearer</strong>, because it is immediately obvious what facilities are being used and where they are coming from. And <strong>more portable</strong>, because namespace clashes cannot occur between LLVM code and other namespaces. The portability rule is important because different standard library implementations expose different symbols (potentially ones they shouldn’t), and future revisions to the C++ standard will add more symbols to the <code>std</code> namespace. As such, we never use <code>'using namespace std;'</code> in LLVM.</p><p>【译】在实现文件（如<code>.cpp文件</code>）中，这条规范更像是一种格式规范，但依然很重要。 基本上，使用显式命名空间前缀可以使代码更清晰，因为用了什么、在哪儿定义将会变得显而易见。 而且可以避免LLVM代码和其他命名空间之间发生命名空间冲突，代码更具可移植性。 可移植性规则很重要，因为不同的标准库实现对外暴露了不同的符号（可能有些不应该暴露），随着将来对C ++标准的修订，<code>std</code>命名空间中将会添加更多符号。 因此，我们从不在LLVM中使用&rsquo;using namespace std;' 。</p><p>The exception to the general rule (i.e. it’s not an exception for the <code>std</code> namespace) is for implementation files. For example, all of the code in the LLVM project implements code that lives in the ‘llvm’ namespace. As such, it is ok, and actually clearer, for the <code>.cpp</code> files to have a <code>'using namespace llvm;'</code> directive at the top, after the <code>#include</code>s. This reduces indentation in the body of the file for source editors that indent based on braces, and keeps the conceptual context cleaner. The general form of this rule is that any <code>.cpp</code> file that implements code in any namespace may use that namespace (and its parents’), but should not use any others.</p><p>【译】针对实现文件，也有例外（即，它不是针对std命名空间的例外）。 例如，在LLVM工程中，所有代码都实现了位于“llvm”命名空间中的代码。 因此，对于.cpp文件来说，使用&rsquo;using namespace llvm;&lsquo;是可以的，而且实际上更清楚。 在#includes之后的顶部指令。 这减少了基于大括号缩进的源编辑器的文件正文中的缩进，并使概念上下文更清晰。 此规则的一般形式是，在任何命名空间中实现代码的任何.cpp文件都可以使用该命名空间（及其父节点），但不应使用任何其他命名空间。</p><h4 id=provide-a-virtual-method-anchor-for-classes-in-headershttpllvmorgdocscodingstandardshtmlid45为定义在头文件中的类提供虚函数声明><a href=http://llvm.org/docs/CodingStandards.html#id45>Provide a Virtual Method Anchor for Classes in Headers</a>(为定义在头文件中的类提供虚函数声明)</h4><p>If a class is defined in a header file and has a vtable (either it has virtual methods or it derives from classes with virtual methods), it must always have at least one out-of-line virtual method in the class. Without this, the compiler will copy the vtable and RTTI into every <code>.o</code> file that <code>#include</code>s the header, bloating <code>.o</code> file sizes and increasing link times.</p><p>【译】如果一个类定义在头文件中，并具有虚函数表（无论含有虚函数还是继承自含有虚函数的类），那它必然会有至少一个外联的虚函数。如果没有这个声明，编译器会将虚函数表和RTTI复制到包含此头文件的每个<code>.o</code>文件中，这将增加<code>.o</code>文件的大小和链接时间。</p><h4 id=dont-use-default-labels-in-fully-covered-switches-over-enumerationshttpllvmorgdocscodingstandardshtmlid46枚举成员全覆盖的switch分支中不要使用default标签><a href=http://llvm.org/docs/CodingStandards.html#id46>Don’t use default labels in fully covered switches over enumerations</a>(枚举成员全覆盖的<code>switch</code>分支中，不要使用<code>default</code>标签)</h4><p><code>-Wswitch</code> warns if a switch, without a default label, over an enumeration does not cover every enumeration value. If you write a default label on a fully covered switch over an enumeration then the <code>-Wswitch</code> warning won’t fire when new elements are added to that enumeration. To help avoid adding these kinds of defaults, Clang has the warning <code>-Wcovered-switch-default</code> which is off by default but turned on when building LLVM with a version of Clang that supports the warning.</p><p>【译】对枚举类型进行<code>switch</code>分支选择，如果没有覆盖所有枚举值，且无<code>default</code>标签，则会产生<code>-Wswitch</code>告警。如果为枚举成员全覆盖的<code>switch</code>添加<code>default</code>标签，那么当在枚举类型中添加新成员时，<code>-Wswitch</code>告警就不会触发。为了避免添加这类<code>default</code>，Clang有一个默认关闭的<code>-Wcovered-switch-default</code>告警，它会在使用支持此告警的Clang版本构建LLVM时打开。</p><p>A knock-on effect of this stylistic requirement is that when building LLVM with GCC you may get warnings related to “control may reach end of non-void function” if you return from each case of a covered switch-over-enum because GCC assumes that the enum expression may take any representable value, not just those of individual enumerators. To suppress this warning, use <code>llvm_unreachable</code> after the switch.</p><p>【译】这种风格的规定带来了一个连锁效应，当使用GCC构建LLVM时，如果枚举成员全覆盖的<code>switch</code>的每个<code>case</code>分支均执行<code>return</code>，那将触发和“control may reach end of non-void function”相关的告警。这是因为GCC假定枚举表达式可能包含任何可表示的值，而不仅仅是一个个枚举成员。要避免该告警，在<code>switch</code>分支选择完成后，使用<code>llvm_unreachable</code>。</p><h4 id=use-range-based-for-loops-wherever-possiblehttpllvmorgdocscodingstandardshtmlid47尽可能使用基于范围的for循环><a href=http://llvm.org/docs/CodingStandards.html#id47>Use range-based <code>for</code> loops wherever possible</a>(尽可能使用基于范围的<code>for</code>循环)</h4><p>The introduction of range-based <code>for</code> loops in C++11 means that explicit manipulation of iterators is rarely necessary. We use range-based <code>for</code> loops wherever possible for all newly added code. For example:</p><p>【译】在C ++ 11中引入了基于范围的for循环，这意味着大多数情况下，不需要显式操作迭代器。 我们应尽可能的在所有新增代码重使用基于范围的for循环。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>BasicBlock</span> <span class=o>*</span><span class=n>BB</span> <span class=o>=</span> <span class=p>...</span>
<span class=k>for</span> <span class=p>(</span><span class=n>Instruction</span> <span class=o>&amp;</span><span class=nl>I</span> <span class=p>:</span> <span class=o>*</span><span class=n>BB</span><span class=p>)</span>
  <span class=p>...</span> <span class=n>use</span> <span class=n>I</span> <span class=p>...</span>
</code></pre></td></tr></table></div></div><h4 id=dont-evaluate-end-every-time-through-a-loophttpllvmorgdocscodingstandardshtmlid48不要每轮循环都计算end><a href=http://llvm.org/docs/CodingStandards.html#id48>Don’t evaluate <code>end()</code> every time through a loop</a>(不要每轮循环都计算<code>end()</code>)</h4><p>In cases where range-based <code>for</code> loops can’t be used and it is necessary to write an explicit iterator-based loop, pay close attention to whether <code>end()</code> is re-evaluted on each loop iteration. One common mistake is to write a loop in this style:</p><p>【译】如果无法使用基于范围的for循环，而且有必要写显式迭代器的循环，那就要密切注意是否在每次循环迭代时重新计算<code>end()</code>。 一个常见的错误是以下面这种方式写循环：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>BasicBlock</span> <span class=o>*</span><span class=n>BB</span> <span class=o>=</span> <span class=p>...</span>
<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>I</span> <span class=o>=</span> <span class=n>BB</span><span class=o>-&gt;</span><span class=n>begin</span><span class=p>();</span> <span class=n>I</span> <span class=o>!=</span> <span class=n>BB</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>I</span><span class=p>)</span>
  <span class=p>...</span> <span class=n>use</span> <span class=n>I</span> <span class=p>...</span>
</code></pre></td></tr></table></div></div><p>The problem with this construct is that it evaluates “<code>BB->end()</code>” every time through the loop. Instead of writing the loop like this, we strongly prefer loops to be written so that they evaluate it once before the loop starts. A convenient way to do this is like so:</p><p>【译】这种结构的问题在于每次循环迭代都会计算“<code>BB->end()</code>”。为了不写这样的循环，强烈建议在循环开始前就计算好它。一个不错的实现方式是这样的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>BasicBlock</span> <span class=o>*</span><span class=n>BB</span> <span class=o>=</span> <span class=p>...</span>
<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>I</span> <span class=o>=</span> <span class=n>BB</span><span class=o>-&gt;</span><span class=n>begin</span><span class=p>(),</span> <span class=n>E</span> <span class=o>=</span> <span class=n>BB</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>();</span> <span class=n>I</span> <span class=o>!=</span> <span class=n>E</span><span class=p>;</span> <span class=o>++</span><span class=n>I</span><span class=p>)</span>
  <span class=p>...</span> <span class=n>use</span> <span class=n>I</span> <span class=p>...</span>
</code></pre></td></tr></table></div></div><p>The observant may quickly point out that these two loops may have different semantics: if the container (a basic block in this case) is being mutated, then “<code>BB->end()</code>” may change its value every time through the loop and the second loop may not in fact be correct. If you actually do depend on this behavior, please write the loop in the first form and add a comment indicating that you did it intentionally.</p><p>【译】读者可能会很快指出这两个循环可能有不同的语义：如果容器（在本例中是一个基础块）正在被修改，那么每次循环迭代后“<code>BB->end()</code>”的值都可能发生改变，可能第二次循环就已经不正确了。 如果确实有这样的行为，那请用第一种形式写循环，并且添加注释来说明就是要这样做。</p><p>Why do we prefer the second form (when correct)? Writing the loop in the first form has two problems. First it may be less efficient than evaluating it at the start of the loop. In this case, the cost is probably minor — a few extra loads every time through the loop. However, if the base expression is more complex, then the cost can rise quickly. I’ve seen loops where the end expression was actually something like: “<code>SomeMap[X]->end()</code>” and map lookups really aren’t cheap. By writing it in the second form consistently, you eliminate the issue entirely and don’t even have to think about it.</p><p>【译】为什么倾向于第二种形式（正确的时候）？以第一种形式写循环有两个问题。 首先，它可能会比在循环开始就计算的效率低。 这种情况下，代价可能很小 —— 每次循环都会做一些额外加载。 但是，如果基础表达式变得更复杂，那么代价将会迅速增加。 我见过一些循环，它们的结束表达式实际上像这样：“<code>SomeMap[X]->end()</code>”，而在map中查找的代价真的不小。 通过统一按第二种形式写，这个问题就完全消除了，甚至都不需要考虑。</p><p>The second (even bigger) issue is that writing the loop in the first form hints to the reader that the loop is mutating the container (a fact that a comment would handily confirm!). If you write the loop in the second form, it is immediately obvious without even looking at the body of the loop that the container isn’t being modified, which makes it easier to read the code and understand what it does.</p><p>【译】第二个（甚至更为严重）的问题是，以第一种形式写循环是在提醒读者：循环正在改变容器（注释可以轻易确认的事实！）。 如果以第二种形式写循环，一目了然，甚至都不用看循环体是否修改了容器，这使得阅读和理解代码变得更简单。</p><p>While the second form of the loop is a few extra keystrokes, we do strongly prefer it.</p><p>【译】虽然第二种形式需要打更多的字，但我们确实很推崇它。</p><h4 id=include-iostream-is-forbiddenhttpllvmorgdocscodingstandardshtmlid49禁用include-iostream><a href=http://llvm.org/docs/CodingStandards.html#id49><code>#include &lt;iostream></code> is Forbidden</a>(禁用<code>#include &lt;iostream></code>)</h4><p>The use of <code>#include &lt;iostream></code> in library files is hereby <strong>forbidden</strong>, because many common implementations transparently inject a <a href=http://llvm.org/docs/CodingStandards.html#static-constructor>static constructor</a> into every translation unit that includes it.</p><p>【译】特别声明，禁止在库文件中使用<code>#include &lt;iostream></code>，因为通常的实现方式是显式将静态构造函数注入到每个包含它的转换单元中。</p><p>Note that using the other stream headers (<code>&lt;sstream></code> for example) is not problematic in this regard — just <code>&lt;iostream></code>. However, <code>raw_ostream</code> provides various APIs that are better performing for almost every use than<code>std::ostream</code> style APIs.</p><p>【译】请注意，这仅针对<code>&lt;iostream></code>，其他流的头文件（例如<code>&lt;sstream></code>）在这方面是没有问题的。不过，<code>raw_ostream</code>提供了各种各样的API，几乎每个都比<code>std::ostream</code>样式的更好用。</p><blockquote><p>Note（注意）</p><p>New code should always use <a href=http://llvm.org/docs/CodingStandards.html#raw-ostream>raw_ostream</a> for writing, or the <code>llvm::MemoryBuffer</code> API for reading files.</p><p>【译】新增代码应该始终用<code>raw_ostream</code>，或使用<code>llvm::MemoryBuffer</code>接口读文件。</p></blockquote><h4 id=use-raw_ostreamhttpllvmorgdocscodingstandardshtmlid50使用raw_ostream><a href=http://llvm.org/docs/CodingStandards.html#id50>Use <code>raw_ostream</code></a>(使用<code>raw_ostream</code>)</h4><p>LLVM includes a lightweight, simple, and efficient stream implementation in <code>llvm/Support/raw_ostream.h</code>, which provides all of the common features of <code>std::ostream</code>. All new code should use <code>raw_ostream</code> instead of <code>ostream</code>.</p><p>【译】LLVM在<code>llvm/Support/raw_ostream.h</code>中包含了一个轻量级、简单并且高效的流实现，它提供了<code>std::ostream</code>的所有通用特性。所有新增代码都应该使用<code>raw_ostream</code>而不是<code>ostream</code>。</p><p>Unlike <code>std::ostream</code>, <code>raw_ostream</code> is not a template and can be forward declared as <code>class raw_ostream</code>. Public headers should generally not include the <code>raw_ostream</code> header, but use forward declarations and constant references to <code>raw_ostream</code> instances.</p><p>【译】与<code>std::ostream</code>不同，<code>raw_ostream</code>不是模板，并可以前向声明为<code>class raw_ostream</code>。公共头文件通常不应该包含<code>raw_ostream</code>头文件，但可以用前向声明，以及<code>raw_ostream</code>实例的常量引用。</p><h4 id=avoid-stdendlhttpllvmorgdocscodingstandardshtmlid51避免使用stdendl><a href=http://llvm.org/docs/CodingStandards.html#id51>Avoid <code>std::endl</code></a>(避免使用<code>std::endl</code>)</h4><p>The <code>std::endl</code> modifier, when used with <code>iostreams</code> outputs a newline to the output stream specified. In addition to doing this, however, it also flushes the output stream. In other words, these are equivalent:</p><p>【译】当与<code>iostreams</code>一起使用时，<code>std::endl</code>修饰符会向指定的输出流中输出一个换行符。而且除了这个，它还是会刷新输出流缓冲区，等于这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>flush</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>Most of the time, you probably have no reason to flush the output stream, so it’s better to use a literal <code>'\n'</code>.</p><p>【译】大多数情况下，可能没有什么理由去刷新输出流缓冲区，最好使用<code>'\n'</code>。</p><h4 id=dont-use-inline-when-defining-a-function-in-a-class-definitionhttpllvmorgdocscodingstandardshtmlid52不需要对类的成员函数使用inline><a href=http://llvm.org/docs/CodingStandards.html#id52>Don’t use <code>inline</code> when defining a function in a class definition</a>(不需要对类的成员函数使用<code>inline</code>)</h4><p>A member function defined in a class definition is implicitly inline, so don’t put the <code>inline</code> keyword in this case.</p><p>【译】类的成员函数默认隐式内联，所以在这种情况下不需要使用<code>inline</code>关键字。</p><p>Don’t:</p><p>【译】不要这样做：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=kr>inline</span> <span class=kt>void</span> <span class=n>bar</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>};</span>
</code></pre></td></tr></table></div></div><p>Do:</p><p>【译】这样做：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=kt>void</span> <span class=n>bar</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>};</span>
</code></pre></td></tr></table></div></div><h3 id=microscopic-detailshttpllvmorgdocscodingstandardshtmlid53小细节><a href=http://llvm.org/docs/CodingStandards.html#id53>Microscopic Details</a>(小细节)</h3><p>This section describes preferred low-level formatting guidelines along with reasoning on why we prefer them.</p><p>【译】本节描述了更为初级的格式化指导，以及为什么更偏向于使用它们。</p><h4 id=spaces-before-parentheseshttpllvmorgdocscodingstandardshtmlid54括号前的空格><a href=http://llvm.org/docs/CodingStandards.html#id54>Spaces Before Parentheses</a>(括号前的空格)</h4><p>We prefer to put a space before an open parenthesis only in control flow statements, but not in normal function call expressions and function-like macros. For example, this is good:</p><p>【译】我们倾向于在控制流语句的括号前加一个空格，在普通函数调用表达式以及函数似的宏前则不加。例如，这样可以：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>X</span><span class=p>)</span> <span class=p>...</span>
<span class=k>for</span> <span class=p>(</span><span class=n>I</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>I</span> <span class=o>!=</span> <span class=mi>100</span><span class=p>;</span> <span class=o>++</span><span class=n>I</span><span class=p>)</span> <span class=p>...</span>
<span class=k>while</span> <span class=p>(</span><span class=n>LLVMRocks</span><span class=p>)</span> <span class=p>...</span>

<span class=n>somefunc</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>
<span class=n>assert</span><span class=p>(</span><span class=mi>3</span> <span class=o>!=</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;laws of math are failing me&#34;</span><span class=p>);</span>

<span class=n>A</span> <span class=o>=</span> <span class=n>foo</span><span class=p>(</span><span class=mi>42</span><span class=p>,</span> <span class=mi>92</span><span class=p>)</span> <span class=o>+</span> <span class=n>bar</span><span class=p>(</span><span class=n>X</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>and this is bad:</p><p>【译】这样不行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span><span class=p>(</span><span class=n>X</span><span class=p>)</span> <span class=p>...</span>
<span class=k>for</span><span class=p>(</span><span class=n>I</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>I</span> <span class=o>!=</span> <span class=mi>100</span><span class=p>;</span> <span class=o>++</span><span class=n>I</span><span class=p>)</span> <span class=p>...</span>
<span class=k>while</span><span class=p>(</span><span class=n>LLVMRocks</span><span class=p>)</span> <span class=p>...</span>

<span class=n>somefunc</span> <span class=p>(</span><span class=mi>42</span><span class=p>);</span>
<span class=n>assert</span> <span class=p>(</span><span class=mi>3</span> <span class=o>!=</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;laws of math are failing me&#34;</span><span class=p>);</span>

<span class=n>A</span> <span class=o>=</span> <span class=n>foo</span> <span class=p>(</span><span class=mi>42</span><span class=p>,</span> <span class=mi>92</span><span class=p>)</span> <span class=o>+</span> <span class=n>bar</span> <span class=p>(</span><span class=n>X</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>The reason for doing this is not completely arbitrary. This style makes control flow operators stand out more, and makes expressions flow better. The function call operator binds very tightly as a postfix operator. Putting a space after a function name (as in the last example) makes it appear that the code might bind the arguments of the left-hand-side of a binary operator with the argument list of a function and the name of the right side. More specifically, it is easy to misread the “<code>A</code>” example as:</p><p>【译】这样做的原因并不完全是随意的。 这种风格使控制流操作显得更加突出，使之可以更好的表达。 函数调用运算符作为后缀运算符连接的非常紧密。 在函数名后添加一个空格（如上例所示）会让代码看起来就像，函数的参数列表作为二元运算符左侧的参数和右侧的名称绑定在一起。 更具体地说，很容易将“<code>A</code>”示例误读成下面这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>A</span> <span class=o>=</span> <span class=n>foo</span> <span class=p>((</span><span class=mi>42</span><span class=p>,</span> <span class=mi>92</span><span class=p>)</span> <span class=o>+</span> <span class=n>bar</span><span class=p>)</span> <span class=p>(</span><span class=n>X</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>when skimming through the code. By avoiding a space in a function, we avoid this misinterpretation.</p><p>【译】通过不在函数中的添加这样的空格，我们就避免了这种误解。</p><h4 id=prefer-preincrementhttpllvmorgdocscodingstandardshtmlid55优先使用前自增><a href=http://llvm.org/docs/CodingStandards.html#id55>Prefer Preincrement</a>(优先使用前自增)</h4><p>Hard fast rule: Preincrement (<code>++X</code>) may be no slower than postincrement (<code>X++</code>) and could very well be a lot faster than it. Use preincrementation whenever possible.</p><p>【译】规范概览：前自增（<code>++X</code>）可能不比后自增（<code>X++</code>）慢，并且可能比它快很多。 尽可能使用前自增。</p><p>The semantics of postincrement include making a copy of the value being incremented, returning it, and then preincrementing the “work value”. For primitive types, this isn’t a big deal. But for iterators, it can be a huge issue (for example, some iterators contains stack and set objects in them… copying an iterator could invoke the copy ctor’s of these as well). In general, get in the habit of always using preincrement, and you won’t have a problem.</p><p>【译】后自增的语义包含拷贝待自增的值，返回它，然后前自增“工作值”。 对于原生类型，这不是什么大问题。 但对于迭代器来说，它可能是一个巨大的问题（例如，一些迭代器包含栈和集合对象&mldr;复制迭代器可能会同时调用这些迭代器的拷贝构造函数）。 一般来说，养成一直使用前自增的习惯就不会有问题了。</p><h4 id=namespace-indentationhttpllvmorgdocscodingstandardshtmlid56命名空间的缩进><a href=http://llvm.org/docs/CodingStandards.html#id56>Namespace Indentation</a>(命名空间的缩进)</h4><p>In general, we strive to reduce indentation wherever possible. This is useful because we want code to <a href=http://llvm.org/docs/CodingStandards.html#fit-into-80-columns>fit into 80 columns</a> without wrapping horribly, but also because it makes it easier to understand the code. To facilitate this and avoid some insanely deep nesting on occasion, don’t indent namespaces. If it helps readability, feel free to add a comment indicating what namespace is being closed by a <code>}</code>. For example:</p><p>【译】一般来讲，我们尽可能地努力减少缩进。 这很有用，因为我们希望代码可以适配80列，而且没什么不友好的东西包住它，也因为这会使代码更容易理解。 为了方便做到这一点，并避免一些疯狂的深度嵌套，那就不对命名空间缩进。 如果在闭合命名空间的<code>}</code>处添加命名空间注释，可以帮助提高可读性，尽管去做。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>namespace</span> <span class=n>llvm</span> <span class=p>{</span>
<span class=k>namespace</span> <span class=n>knowledge</span> <span class=p>{</span>

<span class=c1>/// This class represents things that Smith can have an intimate
</span><span class=c1>/// understanding of and contains the data associated with it.
</span><span class=c1></span><span class=k>class</span> <span class=nc>Grokable</span> <span class=p>{</span>
<span class=p>...</span>
<span class=k>public</span><span class=o>:</span>
  <span class=k>explicit</span> <span class=n>Grokable</span><span class=p>()</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
  <span class=k>virtual</span> <span class=o>~</span><span class=n>Grokable</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=p>...</span>

<span class=p>};</span>

<span class=p>}</span> <span class=c1>// end namespace knowledge
</span><span class=c1></span><span class=p>}</span> <span class=c1>// end namespace llvm
</span></code></pre></td></tr></table></div></div><p>Feel free to skip the closing comment when the namespace being closed is obvious for any reason. For example, the outer-most namespace in a header file is rarely a source of confusion. But namespaces both anonymous and named in source files that are being closed half way through the file probably could use clarification.</p><p>【译】无论出于什么原因，当闭合的命名空间很明显时，可以随意跳过闭合注释。 例如，头文件中最外层的命名空间很少会引起混淆。 但是在源文件中，匿名和具名的命名空间可能会在文件的中途被闭合，所以需要使用注释。</p><h4 id=anonymous-namespaceshttpllvmorgdocscodingstandardshtmlid57匿名空间的缩进><a href=http://llvm.org/docs/CodingStandards.html#id57>Anonymous Namespaces</a>(匿名空间的缩进)</h4><p>After talking about namespaces in general, you may be wondering about anonymous namespaces in particular. Anonymous namespaces are a great language feature that tells the C++ compiler that the contents of the namespace are only visible within the current translation unit, allowing more aggressive optimization and eliminating the possibility of symbol name collisions. Anonymous namespaces are to C++ as “static” is to C functions and global variables. While “<code>static</code>” is available in C++, anonymous namespaces are more general: they can make entire classes private to a file.</p><p>【译】聊过通常的命名空间后，你可能会特别想知道匿名空间。 匿名空间是一种很好的语言特性，它告诉C++编译器，该命名空间的内容仅在当前转换单元中可见，可以使用更激进的优化，同时可以消除符号名称冲突的可能性。 匿名空间对于C++，就像“static”对于C函数和全局变量。 虽然C++中提供了“static”，但匿名空间更为通用：它们可以使整个类变为文件私有。</p><p>The problem with anonymous namespaces is that they naturally want to encourage indentation of their body, and they reduce locality of reference: if you see a random function definition in a C++ file, it is easy to see if it is marked static, but seeing if it is in an anonymous namespace requires scanning a big chunk of the file.</p><p>【译】匿名空间的问题在于，它们很自然的希望更多的对内容进行缩进，以及减少了引用的局部性：如果在C ++文件中看到随便一个函数定义，很容易看出它是否标记为<code>static</code>，但是判断是否位于匿名命名空间中，则需要阅读文件的一大段。</p><p>Because of this, we have a simple guideline: make anonymous namespaces as small as possible, and only use them for class declarations. For example, this is good:</p><p>【译】因此，我们有一个简单的准则：使匿名空间尽可能小，并且只将它们用于类声明。 例如，这就很好：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>namespace</span> <span class=p>{</span>
<span class=k>class</span> <span class=nc>StringSort</span> <span class=p>{</span>
<span class=p>...</span>
<span class=k>public</span><span class=o>:</span>
  <span class=n>StringSort</span><span class=p>(...)</span>
  <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>RHS</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
<span class=p>};</span>
<span class=p>}</span> <span class=c1>// end anonymous namespace
</span><span class=c1></span>
<span class=k>static</span> <span class=kt>void</span> <span class=nf>runHelper</span><span class=p>()</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>

<span class=kt>bool</span> <span class=n>StringSort</span><span class=o>::</span><span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>RHS</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>This is bad:</p><p>【译】这就不行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>namespace</span> <span class=p>{</span>

<span class=k>class</span> <span class=nc>StringSort</span> <span class=p>{</span>
<span class=p>...</span>
<span class=k>public</span><span class=o>:</span>
  <span class=n>StringSort</span><span class=p>(...)</span>
  <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>RHS</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
<span class=p>};</span>

<span class=kt>void</span> <span class=nf>runHelper</span><span class=p>()</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>

<span class=kt>bool</span> <span class=n>StringSort</span><span class=o>::</span><span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>RHS</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>

<span class=p>}</span> <span class=c1>// end anonymous namespace
</span></code></pre></td></tr></table></div></div><p>This is bad specifically because if you’re looking at “<code>runHelper</code>” in the middle of a large C++ file, that you have no immediate way to tell if it is local to the file. When it is marked static explicitly, this is immediately obvious. Also, there is no reason to enclose the definition of “<code>operator&lt;</code>” in the namespace just because it was declared there.</p><p>【译】如果在一个庞大C ++文件的中间查看“runHelper”，但没法立即判断出它是否在这个文件中，这就会非常糟糕。 当显示标记为<code>static</code>时，这就很明显。 此外，没有理由将“<code>operator &lt;</code>”的定义限制在匿名空间中，仅仅是因为是在那里声明的。</p><h2 id=see-alsohttpllvmorgdocscodingstandardshtmlid58><a href=http://llvm.org/docs/CodingStandards.html#id58>See Also</a></h2><p>A lot of these comments and recommendations have been culled from other sources. Two particularly important books for our work are:</p><ol><li><a href=https://www.amazon.com/Effective-Specific-Addison-Wesley-Professional-Computing/dp/0321334876>Effective C++</a> by Scott Meyers. Also interesting and useful are “More Effective C++” and “Effective STL” by the same author.</li><li><a href=https://www.amazon.com/Large-Scale-Software-Design-John-Lakos/dp/0201633620>Large-Scale C++ Software Design</a> by John Lakos</li></ol><p>If you get some free time, and you haven’t read them: do so, you might learn something.</p><p>© Copyright 2003-2019, LLVM Project. Last updated on 2019-06-05. Created using <a href=http://sphinx-doc.org/>Sphinx</a> 1.7.6.</p><h1 id=译注>译注</h1></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>孤梦</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2019-07-15</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/coding-guide/>coding-guide</a>
<a href=/tags/c/c++/>c/c++</a>
<a href=/tags/llvm/>llvm</a></div><nav class=post-nav><a class=prev href=/post/pg/%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E6%80%A7%E5%8F%8D%E6%80%9D/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">结构化设计阶段性反思</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%8E%BB%E7%92%83%E7%AC%BC%E5%AD%90/><span class="next-text nav-default">读书笔记：玻璃笼子</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:your@email.com class="iconfont icon-email" title=email></a><a href=http://localhost:1313 class="iconfont icon-stack-overflow" title=stack-overflow></a><a href=http://localhost:1313 class="iconfont icon-twitter" title=twitter></a><a href=http://localhost:1313 class="iconfont icon-facebook" title=facebook></a><a href=http://localhost:1313 class="iconfont icon-linkedin" title=linkedin></a><a href=http://localhost:1313 class="iconfont icon-google" title=google></a><a href=http://localhost:1313 class="iconfont icon-github" title=github></a><a href=http://localhost:1313 class="iconfont icon-weibo" title=weibo></a><a href=http://localhost:1313 class="iconfont icon-zhihu" title=zhihu></a><a href=http://localhost:1313 class="iconfont icon-douban" title=douban></a><a href=http://localhost:1313 class="iconfont icon-pocket" title=pocket></a><a href=http://localhost:1313 class="iconfont icon-tumblr" title=tumblr></a><a href=http://localhost:1313 class="iconfont icon-instagram" title=instagram></a><a href=http://localhost:1313 class="iconfont icon-gitlab" title=gitlab></a><a href=http://localhost:1313 class="iconfont icon-bilibili" title=bilibili></a><a href=http://localhost:1313/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2012 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>孤梦</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script></body></html>