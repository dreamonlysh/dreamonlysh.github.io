<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on gumeng's blog.</title><link>https://blog.guyuemeng.com/post/</link><description>Recent content in Posts on gumeng's blog.</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 04 Jun 2021 16:56:18 +0800</lastBuildDate><atom:link href="https://blog.guyuemeng.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>blog: hugo + github + typora</title><link>https://blog.guyuemeng.com/post/pg_sundry/hugo/blog-hugo+github+typora/</link><pubDate>Fri, 04 Jun 2021 16:56:18 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg_sundry/hugo/blog-hugo+github+typora/</guid><description>问题1 问题描述：github pages对应的仓未能生成index.html，本地hugo servrer可以正常显示 解决方案： 1 git submodule add https://github.com/olOwOlo/hugo-theme-even themes/even 通过</description></item><item><title>019 overloaded lambda</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/019_overloaded_lambda/</link><pubDate>Mon, 22 Feb 2021 22:15:22 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/019_overloaded_lambda/</guid><description>Overloaded lambda 一个有趣的话题：如何重载lambda。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &amp;lt;iomanip&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;type_traits&amp;gt;#include &amp;lt;variant&amp;gt;#include &amp;lt;vector&amp;gt; // the variant to visit using var_t = std::variant&amp;lt;int, long, double, std::string&amp;gt;; // helper type</description></item><item><title>018 default initialization</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/018_default_initialization/</link><pubDate>Wed, 11 Nov 2020 19:01:22 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/018_default_initialization/</guid><description>Default Initialization[1] 1 2 3 4 5 // Syntax T object; new T new T() // (until C++03) 默认初始化场景 具有automatic(栈上)、static、thread-local生命周期的对象未显示</description></item><item><title>015 17s structured binding declaration</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/015_17s_structured_binding_declaration/</link><pubDate>Sun, 17 May 2020 21:31:02 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/015_17s_structured_binding_declaration/</guid><description>Video Link: C++ Weekly - Ep 24 C++17&amp;rsquo;s Structured Bindings Verification Case 结构化绑定是一个比较有意思的功能，从某个角度来看，使用{}可以将数据打包成tuple/array/class等，结构</description></item><item><title>014 17s nested namespace</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/014_17s_nested_namespace/</link><pubDate>Sun, 17 May 2020 17:04:06 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/014_17s_nested_namespace/</guid><description>Video Link: C++ Weekly - Ep 22 C++17&amp;rsquo;s Nested Namespaces and std::clamp Verification Case 嵌套命名空间是一个非常小的写法改进，如： 1 2 3 4 // Style1 namespace A { namespace B { namespace C { }}} 或： 1 2 3 4 5 6 7 8 // Style2 namespace A { namespace B { namespace C</description></item><item><title>013 17s if with initializer</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/013_17s_if_with_initializer/</link><pubDate>Sat, 16 May 2020 23:23:28 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/013_17s_if_with_initializer/</guid><description>Video Link: C++ Weekly - Ep 21 C++17&amp;rsquo;s if and switch Init Statements 应用场景 首先看下其等效表达[1]： 1 2 3 4 5 6 7 { init_statement if constexpr(optional) ( condition ) statement-true else statement-false } 与普通的if几乎相同，唯一的区别是最外层的{</description></item><item><title>012 17s constexpr if</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/012_17s_constexpr_if/</link><pubDate>Mon, 11 May 2020 20:43:00 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/012_17s_constexpr_if/</guid><description>Video Link: C++ Weekly - Ep 18 C++17&amp;rsquo;s constexpr if Verification Case constexpr if用于在编译期进行分支选择，不满足条件的分支在编译期被丢弃。从某种程度上来说，constexpr if有着#if.</description></item><item><title>011 member function factory</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/011_member_function_factory/</link><pubDate>Mon, 27 Apr 2020 00:33:56 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/011_member_function_factory/</guid><description>010_17s_invoke提到的std::invoke提供了统一的非静态成员函数和普通函数的统一调用，但遗留个问题：使用场景。 回忆方舟编译</description></item><item><title>010 17s invoke</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/010_17s_invoke/</link><pubDate>Sat, 25 Apr 2020 19:43:08 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/010_17s_invoke/</guid><description>Video Link: C++ Weekly - Ep 17 C++17&amp;rsquo;s std::invoke Background 非静态成员函数与普通函数在使用函数指针进行调用的方式不同[1][2]。 普通函数指针： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int sum(int lhs,</description></item><item><title>009 lambda rather than bind</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/009_lambda_rather_than_bind/</link><pubDate>Sun, 19 Apr 2020 21:52:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/009_lambda_rather_than_bind/</guid><description>Video Link: C++ Weekly - Ep 15 Using std::bind, C++ Weekly - Ep 16 Avoiding std::bind Verification Case 示例如下，有add函数： 1 2 3 int add(int a, int b) { return a + b; } 现要通过其支持步进1(add(i, 1))，使用std</description></item><item><title>008 17s fold expression</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/008_17s_fold_expression/</link><pubDate>Wed, 15 Apr 2020 23:39:49 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/008_17s_fold_expression/</guid><description>本文用于初步探索C++17引入的fold expression特性来简化parameter pack的使用。 Verification Case 在&amp;quot;003_refac</description></item><item><title>007 14s exchange</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/007_14s_exchange/</link><pubDate>Mon, 13 Apr 2020 23:30:53 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/007_14s_exchange/</guid><description>Video Link: C++ Weekly - Ep 14 Standard Library Gems: next and exchange Optimization Case https://gitee.com/harmonyos/OpenArkCompiler/blob/master/src/maple_ir/src/mir_lower.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BlockNode *MIRLower::LowerBlock(BlockNode &amp;amp;block) { auto *newBlock = mirModule.CurFuncCodeMemPool()-&amp;gt;New&amp;lt;BlockNode&amp;gt;(); BlockNode *tmp = nullptr; if (block.GetFirst() == nullptr) { return newBlock; } StmtNode *nextStmt = block.GetFirst(); ASSERT(nextStmt != nullptr, &amp;#34;nullptr check&amp;#34;); do { StmtNode *stmt = nextStmt; nextStmt = stmt-&amp;gt;GetNext(); //</description></item><item><title>006 17s any</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/006_17s_any/</link><pubDate>Sun, 12 Apr 2020 17:28:08 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/006_17s_any/</guid><description>本文用于初步探索C++17引入的std::any的使用。 Verification Case 知识补充 c++是静态类型的语言，python是动态类型的语言。从个人经历而言，很</description></item><item><title>005 17s optional</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/005_17s_optional/</link><pubDate>Thu, 09 Apr 2020 23:55:36 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/005_17s_optional/</guid><description>本文用于初步探索C++17引入的std::optional的使用与性能。 Verification Case 知识补充 如下代码，或多或少还是会见到一些： 1 2 3 4 5 6 7 8 9 10 11</description></item><item><title>004 usage of static local</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/004_usage_of_static_local/</link><pubDate>Mon, 06 Apr 2020 22:24:12 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/004_usage_of_static_local/</guid><description>Video Link: C++ Weekly - Ep 2 Cost of Using Statics 此视频的目的是探索static局部变量的开销。 Verification Case 知识补充 c++ 11前单件的实现需要线程安全的双重校验，其实现可能如下： 1</description></item><item><title>003 refactor multi fill to single expression</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/003_refactor_multi_fill_to_single_expression/</link><pubDate>Sat, 04 Apr 2020 23:44:46 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/003_refactor_multi_fill_to_single_expression/</guid><description>基于002_refactor_char_operation_to_utility中的初始化，依然有两点对于应用不友好： 多次书写单个参数不同的</description></item><item><title>002 refactor char operation to utility</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/002_refactor_char_operation_to_utility/</link><pubDate>Sat, 04 Apr 2020 18:48:13 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/002_refactor_char_operation_to_utility/</guid><description>基于001_refactor_logic_to_static中的模块提供更为通用的抽象，凸显主题业务，并提高代码可复用性。 待优化的代码如下：</description></item><item><title>001 refactor logic to static</title><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/001_refactor_logic_to_static/</link><pubDate>Fri, 03 Apr 2020 18:25:34 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/001_refactor_logic_to_static/</guid><description>Video Link: C++ Weekly - Ep 1 ChaiScript_Parser Initialization Refactor 此视频的目标：将代码中具有初始化语义的代码进行重构，以此可以更多的利用编译器能力进行优化，从而获得更高的性能。 Optimization Case https://gitee.com/harmonyos/OpenArkCompiler/blob/master/src/maple_ir/src/lexer.cpp 1 2</description></item><item><title>GN Overview</title><link>https://blog.guyuemeng.com/post/pg_ci/build/gn/</link><pubDate>Sun, 22 Mar 2020 22:35:26 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg_ci/build/gn/</guid><description>Overview 定义一个工具链配置，配置名为&amp;quot;gcc&amp;quot; 1 toolchain(&amp;#34;gcc&amp;#34;) { 工具链中工具配置(tool) 1 tool(&amp;#34;cc&amp;#34;) { Compiler tools所支持头文件依赖(编译依赖.</description></item><item><title>方舟编译器C++语言编程规范增强:空行</title><link>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/ark_coding/02-%E7%A9%BA%E8%A1%8C/</link><pubDate>Fri, 07 Feb 2020 16:32:26 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/ark_coding/02-%E7%A9%BA%E8%A1%8C/</guid><description>文章通过段落将内容变得更具节奏，代码通过换行来达到相同的效果。换行对于代码阅读来说非常重要，过多的空行会减少屏幕显示的有效代码；过少的空行又</description></item><item><title>方舟编译器C++语言编程规范增强:注释</title><link>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/ark_coding/01-%E6%B3%A8%E9%87%8A/</link><pubDate>Mon, 03 Feb 2020 16:50:26 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/ark_coding/01-%E6%B3%A8%E9%87%8A/</guid><description>注释风格 代码注释依据其面向的读者不同，可以分为接口注释与实现注释。 接口注释，重点在于描述业务功能、调用方式、注意事项等，为了使调用者无需了解</description></item><item><title>方舟编译器C++语言编程规范增强:序言</title><link>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/ark_coding/00-%E5%BA%8F%E8%A8%80/</link><pubDate>Mon, 03 Feb 2020 09:10:26 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/ark_coding/00-%E5%BA%8F%E8%A8%80/</guid><description>背景 《方舟编译器C++语言编程规范》主体部分起源于《华为C++语言通用编码规范》，据悉又参考《Google C++ Style Guide》引入部分内容，其定</description></item><item><title>结构化设计阶段性反思</title><link>https://blog.guyuemeng.com/post/pg/%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E6%80%A7%E5%8F%8D%E6%80%9D/</link><pubDate>Fri, 19 Jul 2019 18:03:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg/%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E6%80%A7%E5%8F%8D%E6%80%9D/</guid><description>结构化设计，本想用架构作为标题，但现有的眼光尚显短浅，避免标题党的哗众取宠。 结构化设计是一种相当宽泛的概念，几乎所有的归类思考都可以理解成结</description></item><item><title>LLVM编码规范(译)</title><link>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/llvm%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E8%AF%91/</link><pubDate>Mon, 15 Jul 2019 23:39:17 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/llvm%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E8%AF%91/</guid><description>LLVM Coding Standards(LLVM编码规范) [TOC] Introduction(简介) This document attempts to describe a few coding standards that are being used in the LLVM source tree. Although no coding standards should be regarded as absolute requirements to be followed in</description></item><item><title>读书笔记：玻璃笼子</title><link>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%8E%BB%E7%92%83%E7%AC%BC%E5%AD%90/</link><pubDate>Sun, 10 Mar 2019 14:13:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%8E%BB%E7%92%83%E7%AC%BC%E5%AD%90/</guid><description>前些年AlphaGo战胜世界围棋冠军一度走红，随后人工智能的宣传铺天盖地的进入大众视野，机器学习、深度学习也成为程序员们闲聊与研究的热点。经</description></item><item><title>老干妈Python-首章</title><link>https://blog.guyuemeng.com/post/pgl_python/%E8%80%81%E5%B9%B2%E5%A6%88python-%E9%A6%96%E7%AB%A0/</link><pubDate>Mon, 20 Aug 2018 21:59:59 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_python/%E8%80%81%E5%B9%B2%E5%A6%88python-%E9%A6%96%E7%AB%A0/</guid><description>自然语言 vs 计算机语言 面对俩资料老干妈，从文入武，想想可能只有从语言的共性入手了。 目标：尝试去描述Python语言学习的过程，约束并制定后续讲</description></item><item><title>读书笔记： Google软件测试之道</title><link>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/</link><pubDate>Sat, 04 Aug 2018 11:32:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/</guid><description>平凡是一种态度，平庸是个人能力，平凡之人岂可平庸！（工作篇） 程序员的现状，以体力劳动者的身份参与软件生产活动。作为一软件工程师，或程序员，或</description></item><item><title>读书笔记：人人牛-管理人力资源(1)</title><link>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%BA%E4%BA%BA%E7%89%9B-%E7%AE%A1%E7%90%86%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%901/</link><pubDate>Sat, 04 Aug 2018 11:32:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%BA%E4%BA%BA%E7%89%9B-%E7%AE%A1%E7%90%86%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%901/</guid><description>书名《人件》 这本书很有意思，结合加班文化来说，这饼画的有些大。回想身边的80后，85后，90后，乃至新出炉的95后，技术基础越来越扎实、起点</description></item><item><title>Vim Habits of GM</title><link>https://blog.guyuemeng.com/post/pg_sundry/vim/vimhabitsofgm/</link><pubDate>Sun, 10 Jun 2018 18:54:34 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg_sundry/vim/vimhabitsofgm/</guid><description>此文献给一只猪和一头牛 影响开发效率的因素很多，有一项基本要素是编码过程中思维的连续程度。程序员开发代码往往不是线性效率，设计与实现是一件非常</description></item><item><title>读书笔记：高效能程序员的修炼(2)</title><link>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E9%AB%98%E6%95%88%E8%83%BD%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BF%AE%E7%82%BC2/</link><pubDate>Mon, 04 Jun 2018 22:49:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E9%AB%98%E6%95%88%E8%83%BD%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BF%AE%E7%82%BC2/</guid><description>学海无边 作者（Jeff Atwood）在Twitter上发的一条短讯： “每一天，你一定要一起床就热情澎湃。否则，你就只是在打工。” 把一堆烂事搞</description></item><item><title>读书笔记：高效能程序员的修炼(1)</title><link>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E9%AB%98%E6%95%88%E8%83%BD%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BF%AE%E7%82%BC1/</link><pubDate>Sun, 03 Jun 2018 22:55:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E9%AB%98%E6%95%88%E8%83%BD%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BF%AE%E7%82%BC1/</guid><description>《高效能程序员的修炼》从书名来看，像是写给程序员们的葵花宝典，事实也是。但当程序员阅读此书，会发现其中的道理不仅仅面向了程序员，对诸多职业也</description></item><item><title>RB-tree</title><link>https://blog.guyuemeng.com/post/pg_algorithm/rb-tree/</link><pubDate>Tue, 15 May 2018 23:24:28 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg_algorithm/rb-tree/</guid><description>《STL源码分析》中关于红黑树（RB-tree）的描述引发的思考： 如何解决一个问题 一般而言，问题域会分解为下面几个方面： a. 期望结果是什么？可</description></item><item><title>一句话设计模式：工厂模式</title><link>https://blog.guyuemeng.com/post/pg/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 08 Jan 2018 23:07:10 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>一句话 对象生产细节的隐藏，适用工厂模式 解析 前段时间有个笑话，话说马云突然饿了，就对属下说：给我买个肯德基，结果，属下就把肯德基收购了！。以此</description></item><item><title>一句话设计模式：单例模式</title><link>https://blog.guyuemeng.com/post/pg/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 08 Jan 2018 19:10:02 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>前言 迷迷糊糊的混了几年编码界，号称编码界除名人员，所幸尚未被编码界除名。这一路走来，听说了不少设计模式，也不知道是记性不好还是怎么地，横竖也</description></item><item><title>C++代码格式规范引导(3)：命名空间</title><link>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/c++%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E5%BC%95%E5%AF%BC3%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link><pubDate>Fri, 03 Nov 2017 23:06:22 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/c++%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E5%BC%95%E5%AF%BC3%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid><description>命名空间 C++语言中的作用域管理方法，大致可以分为两类：物理作用域、逻辑作用域。物理作用域，从磁盘分布、内存管理的角度分离作用域，如工程文件</description></item><item><title>C++代码格式规范引导(2)：头文件</title><link>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/c++%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E5%BC%95%E5%AF%BC2%E5%A4%B4%E6%96%87%E4%BB%B6/</link><pubDate>Wed, 25 Oct 2017 23:35:23 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/c++%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E5%BC%95%E5%AF%BC2%E5%A4%B4%E6%96%87%E4%BB%B6/</guid><description>头文件引用(#include) 头文件的类别大致可以分为以下几类：标准库STL、准标准库Boost、针对C++语言的第三方库(ACE等)、基于</description></item><item><title>C++代码格式规范引导(1)：引言与代码布局</title><link>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/c++%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E5%BC%95%E5%AF%BC1%E5%BC%95%E8%A8%80%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80/</link><pubDate>Fri, 20 Oct 2017 00:00:26 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/coding_guide/c++%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E5%BC%95%E5%AF%BC1%E5%BC%95%E8%A8%80%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80/</guid><description>“房子是用来住的，不是用来炒的”，这是当前最耳熟的一句房政。在我们编码界，有一句话具有着同样的经典意义，也同样耳熟能详，“代码是用来看的，不</description></item><item><title>《Python核心编程(第二版)》引读</title><link>https://blog.guyuemeng.com/post/pgl_python/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%AF%BB/</link><pubDate>Sat, 16 Sep 2017 01:24:00 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_python/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%AF%BB/</guid><description>第一部分 Python核心 第一章 欢迎来到Python世界 本章节1.1-1.3以及1.7-1.9主要讲Python的好处以及相对其他语言的优势。</description></item><item><title>内存泄露分析与规避(CPP)</title><link>https://blog.guyuemeng.com/post/pgl_cc++/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%84%E9%81%BFcpp/</link><pubDate>Mon, 11 Sep 2017 23:06:44 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%84%E9%81%BFcpp/</guid><description>简介 内存泄漏，一言以蔽之：程序运行时，分配在堆上的内存，程序结束后未释放。 触发场景 malloc或realloc创建的对象未free（new创</description></item><item><title>0-2 gtest run flow</title><link>https://blog.guyuemeng.com/post/pg_ci/test/gtest_run_flow/</link><pubDate>Sun, 09 Aug 2015 18:31:39 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg_ci/test/gtest_run_flow/</guid><description>概述 本文主要通过示例代码，描述gtest调用的过程 测试代码结构 代码包含结构 Environment TestFixture1(Test: NoName, Test: WithName) TestFixture2(Test: NoName) TEST 操作打印结果(entered&amp;hellip;/le</description></item><item><title>0-1 gmock run env for VS</title><link>https://blog.guyuemeng.com/post/pg_ci/test/gmock_run_env_for_vs/</link><pubDate>Sun, 09 Aug 2015 10:44:52 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg_ci/test/gmock_run_env_for_vs/</guid><description>概述 本文主要描述如何在vs环境下，搭建可执行的gmock(gtest)运行环境。 环境搭建 编译gmock(以VS2013为例) 选择Win32 P</description></item><item><title>doxygen注释简规(分组)</title><link>https://blog.guyuemeng.com/post/pg_sundry/doxygen/0-1-doxygen%E6%B3%A8%E9%87%8A%E7%AE%80%E8%A7%84%E5%88%86%E7%BB%84/</link><pubDate>Sun, 12 Apr 2015 00:18:46 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg_sundry/doxygen/0-1-doxygen%E6%B3%A8%E9%87%8A%E7%AE%80%E8%A7%84%E5%88%86%E7%BB%84/</guid><description>概述 基础章节主要介绍了doxygen的基本语法，用于注释类、成员、函数等，由此可以生成含有注释的文档。但在拥有基本注释内容的基础上，面对大量</description></item><item><title>doxygen注释简规(基础)</title><link>https://blog.guyuemeng.com/post/pg_sundry/doxygen/0-0-doxygen%E6%B3%A8%E9%87%8A%E7%AE%80%E8%A7%84%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 06 Apr 2015 17:12:13 +0800</pubDate><guid>https://blog.guyuemeng.com/post/pg_sundry/doxygen/0-0-doxygen%E6%B3%A8%E9%87%8A%E7%AE%80%E8%A7%84%E5%9F%BA%E7%A1%80/</guid><description>概述 本文档主要抽取了doxygen中的一种注释方式，用于C++编码的自动文档生成，避免代码中多种风格代码注释的混用。同时考虑到会有JAVA方</description></item><item><title/><link>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/xxx_11s_feature/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.guyuemeng.com/post/pgl_cc++/cpp_memory_leak/xxx_11s_feature/</guid><description> Video Link: C++ Weekly - Ep 9 std::future Quick-Start, C++ Weekly - Ep 11 std::future Part 2</description></item></channel></rss>